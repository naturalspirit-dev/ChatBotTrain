
/*
 * Slot that returns training data for the specified [type], given the
 * specified [threshold], the specified [prompt], the specified [vector_model]
 * and the specified [max_tokens].
 */
slots.create:magic.ai.get-context

   // Sanity checking invocation.
   validators.mandatory:x:@.arguments/*/type
   validators.mandatory:x:@.arguments/*/prompt
   validators.mandatory:x:@.arguments/*/threshold
   validators.mandatory:x:@.arguments/*/max_tokens
   validators.mandatory:x:@.arguments/*/vector_model
   validators.string:x:@.arguments/*/prompt
      min:1

   // Converting threshold in case we're given the wrong type.
   set-value:x:@.arguments/*/threshold
      convert:x:@.arguments/*/threshold
         type:double

   // Retrieving embeddings.
   .token
   set-value:x:@.token
      strings.concat
         .:"Bearer "
         config.get:"magic:openai:key"

   // Retrieving embedding for prompt.
   http.post:"https://api.openai.com/v1/embeddings"
      headers
         Authorization:x:@.token
         Content-Type:application/json
      payload
         input:x:@.arguments/*/prompt
         model:x:@.arguments/*/vector_model
      convert:true

   // Sanity checking above invocation.
   if
      not
         and
            mte:x:@http.post
               .:int:200
            lt:x:@http.post
               .:int:300
      .lambda

         // Oops, error - Logging error and returning OpenAI's HTTP status code to caller.
         lambda2hyper:x:@http.post
         log.error:Something went wrong while invoking OpenAI
            message:x:@http.post/*/content/*/error/*/message
            error:x:@lambda2hyper
         throw:x:@http.post/*/content/*/error/*/message
            public:bool:true
            status:x:@http.post

   // Fetching relevant snippets, making sure we profile the time it takes.
   .begin
   set-value:x:@.begin
      date.now
   .snippets
   .continue:bool:true
   .offset:int:0
   while:x:@.continue

      // Selecting 200 snippets from type.
      data.read
         table:ml_training_snippets
         columns
            id
            embedding
         where
            and
               embedding.neq
               type.eq:x:@.arguments/*/type
         limit:200
         offset:x:@.offset
         order:created

      // Looping through all records returned above.
      for-each:x:@data.read/*

         // Calculating dot product of currently iterated snippet and [.vector].
         math.dot
            strings.split:x:@.dp/#/*/embedding
               .:,
            get-nodes:x:@http.post/*/content/*/data/0/*/embedding/*

         // Checking if dot product is higher than threshold.
         if
            mte:x:@math.dot
               get-value:x:@.arguments/*/threshold
            .lambda

               // Adding result to above [.snippets] collection.
               unwrap:x:+/*/*/*
               add:x:@.snippets
                  .
                     .
                        id:x:@.dp/#/*/id
                        dot:x:@math.dot

      // Sorting [.snippets] such that highest dot product comes first.
      sort:x:@.snippets/*
         if
            mt:x:@.lhs/#/*/dot
               get-value:x:@.rhs/#/*/dot
            .lambda
               set-value:x:@.result
                  .:int:-1
         else-if
            lt:x:@.lhs/#/*/dot
               get-value:x:@.rhs/#/*/dot
            .lambda
               set-value:x:@.result
                  .:int:1
         else
            set-value:x:@.result
               .:int:0

      /*
       * Updating [.snippets] now with the 50 top most relevant snippets.
       *
       * Notice, to make algorithm perform at least to some extent, we avoid
       * adding more than max 50 snippets to [.snippets].
       * These are the top 50 performing snippets according to vectors and
       * dot product.
       */
      remove-nodes:x:@.snippets/*
      add:x:@.snippets
         get-nodes:x:@sort/*/[0,50]

      // Checking if we're done.
      if
         lt
            get-count:x:@data.read/*
            .:int:200
         .lambda

            // We're done! We've found the top 200 most relevant snippets from our training material.
            set-value:x:@.continue
               .:bool:false

      else

         // Incrementing offset.
         math.increment:x:@.offset
            get-count:x:@data.read/*

   // Used to hold the result we're returning to caller.
   .result

   // Context value we return to caller.
   .context:

   // Verifying we actually found anything at all.
   if
      exists:x:@.snippets/*/*
      .lambda

         // Now fetching prompt, completion and URI from snippets.
         add:x:./*/data.read/*/where/*/and/*/id.in
            get-nodes:x:@.snippets/*/*/id
         data.read
            table:ml_training_snippets
            columns
               uri
               prompt
               completion
            where
               and
                  id.in

         // Temporary variable used to calculate tokens.
         .tmp:

         // Pruning snippets until we've got less tokens than [max_tokens].
         .continue:bool:true
         while:x:@.continue

            // Making sure we've got more snippets left.
            if
               not-exists:x:@data.read/0
               .lambda

                  // No more snippets.
                  set-value:x:@.continue
                     .:bool:false

            else

               // Concatenating top snippet to [.tmp] buffer such that we can calculate total number of tokens.
               set-value:x:@.tmp
                  strings.concat
                     get-value:x:@.tmp
                     .:"\r\n"
                     get-value:x:@data.read/0/*/prompt
                     .:"\r\n"
                     .:"\r\n"
                     get-value:x:@data.read/0/*/completion
                     .:"\r\n"

               // Checking if we've got more context to work with.
               if
                  lt
                     openai.tokenize:x:@.tmp
                     get-value:x:@.arguments/*/max_tokens
                  .lambda

                     // We've got room for more context.
                     set-value:x:@.context
                        get-value:x:@.tmp
                     if
                        and
                           not-null:x:@data.read/0/*/uri
                           not-exists:x:@.result/*/*/uri/={@data.read/0/*/uri}
                        .lambda

                           // Adding current reference to [.result]
                           unwrap:x:+/*/*/*
                           add:x:@.result
                              .
                                 .
                                    prompt:x:@data.read/0/*/prompt
                                    uri:x:@data.read/0/*/uri
                     remove-nodes:x:@data.read/0

               else

                  // We're done, no more room for context.
                  set-value:x:@.continue
                     .:bool:false

   // Measuring how much time we spent looping through snippets.
   .end
   set-value:x:@.end
      date.now
   .time
   set-value:x:@.time
      math.subtract
         get-value:x:@.end
         get-value:x:@.begin
   set-value:x:@.time
      time.format:x:@.time
         format:"ss\\.fff"

   // Making sure we found something at all.
   if
      exists:x:@.result/0
      .lambda

         // Trimming [.context] before we return it to caller.
         set-value:x:@.context
            strings.trim:x:@.context
               .:"\r\n"

         // Returning context and relevant snippets to caller.
         add:x:./*/return/*/snippets
            get-nodes:x:@.result/*
         unwrap:x:./*/return/*
         return
            context:x:@.context
            db_time:x:@.time
            snippets
   else

      // Nothing ...
      unwrap:x:+/*
      return
         db_time:x:@.time
