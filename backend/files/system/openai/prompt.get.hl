
// Asks OpenAI a question with the specified type, and returns the answer to caller.
.arguments
   prompt:string
   type:string
   recaptcha_response:string
.description:Asks OpenAI a question with the specified type, and returns the answer to caller
.type:public

// Sanity checking invocation.
validators.mandatory:x:@.arguments/*/prompt
validators.string:x:@.arguments/*/prompt
   min:1

// Trimming prompt.
set-value:x:@.arguments/*/prompt
   strings.trim:x:@.arguments/*/prompt

// Connecting to database to retrieve model settings.
data.connect:[generic|magic]

   // Reading settings for type declaration.
   data.read
      table:ml_types
      columns
         model
         max_tokens
         temperature
         recaptcha
         auth
         supervised
         cached
         prefix
      where
         and
            type.eq:x:@.arguments/*/type

   // Verifying type exists.
   if
      not-exists:x:@data.read/*/*
      .lambda

         // Oops, no such type, making sure we try default type.
         data.read
            table:ml_types
            columns
               model
               max_tokens
               temperature
               recaptcha
               auth
               supervised
               cached
               prefix
            where
               and
                  type.eq:default
         if
            not-exists:x:@data.read/*
            .lambda

               // Default type doesn't exist, nothing to do here.
               throw:No such type
                  status:int:400
                  public:bool:true

         // Resorting to default type.
         add:x:@.lambda/@data.read
            get-nodes:x:@data.read/*
         set-value:x:@.arguments/*/type
            .:default

   // Checking if model requires authentication and authorisation.
   if
      not-null:x:@data.read/*/*/auth
      .lambda
      
         // Making sure user is authorised to using type.
         auth.ticket.verify:x:@data.read/*/*/auth

   // Checking if model requires reCAPTCHA.
   if
      and
         not
            auth.ticket.in-role:root
         mt
            convert:x:@data.read/*/*/recaptcha
               type:decimal
            .:decimal:0
      .lambda

         // Making sure reCAPTCHA value was provided.
         validators.mandatory:x:@.arguments/*/recaptcha_response

         // Retrieving reCAPTCHA site key.
         .key
         set-value:x:@.key
            config.get:"magic:auth:recaptcha:key"

         // Retrieving reCAPTCHA secret.
         .secret
         set-value:x:@.secret
            config.get:"magic:auth:recaptcha:secret"

         // Validating reCAPTCHA invocation confirms request originated from a human.
         convert:x:@data.read/*/*/recaptcha
            type:decimal
         validators.recaptcha:x:@.arguments/*/recaptcha_response
            min:x:@convert
            site-key:x:@.key
            secret:x:@.secret

   // Checking if type is cached.
   if
      mt
         convert:x:@data.read/*/*/cached
            type:int
         .:int:0
      .lambda

         // Checking if query already exists in ml_requests, and if so, returning cached version.
         data.read
            table:ml_requests
            columns
               completion
            where
               and
                  prompt.eq:x:@.arguments/*/prompt
                  type.eq:x:@.arguments/*/type
            limit:1
            order:created
            direction:desc
         if
            exists:x:@data.read/*/*
            .lambda

               // Returning cached completion.
               unwrap:x:+/*
               return
                  result:x:@data.read/*/*/completion
            
   // Creating our Bearer token by reading our OpenAI configuration settings.
   .token
   set-value:x:@.token
      strings.concat
         .:"Bearer "
         config.get:"magic:openai:key"

   // Associating request with user, if applicable.
   auth.ticket.get
   if
      not-null:x:@auth.ticket.get
      .lambda

         // Associating request with username.
         unwrap:x:+/*/*
         add:x:@data.connect/*/http.post/*/payload
            .
               user:x:@auth.ticket.get

   // Decorating prompt according to OpenAI's advice.
   .decorated-prompt
   set-value:x:-
      strings.concat
         get-value:x:@data.read/*/*/prefix
         get-value:x:@.arguments/*/prompt
         .:" ->"

   // Creating an HTTP POST request towards OpenAI, now decorated.
   http.post:"https://api.openai.com/v1/completions"
      headers
         Authorization:x:@.token
         Content-Type:application/json
      payload
         prompt:x:@.decorated-prompt
         model:x:@data.read/*/*/model
         max_tokens:x:@data.read/*/*/max_tokens
         temperature:x:@data.read/*/*/temperature
         stop:" END"
      convert:true

   // Sanity checking above invocation
   if
      not
         and
            mte:x:@http.post
               .:int:200
            lt:x:@http.post
               .:int:300
      .lambda

         // Oops, error - Logging error and returning status 500 to caller.
         lambda2hyper:x:@http.post
         log.error:Something went wrong while invoking OpenAI
            error:x:@http.post/*/content/*/error/*/message
         response.status.set:x:@http.post
         unwrap:x:+/*
         return
            result:x:@http.post/*/content/*/error/*/message

   // Making sure we trim response.
   .result
   set-value:x:@.result
      strings.trim:x:@http.post/*/content/*/choices/0/*/text

   // Checking if type is 'supervised', at which point we store prompt and completion.
   if
      mt
         convert:x:@data.read/*/*/supervised
            type:int
         .:int:0
      .lambda

         // Storing prompt and completion in ml_requests table.
         data.create
            table:ml_requests
            values
               type:x:@.arguments/*/type
               prompt:x:@.arguments/*/prompt
               completion:x:@.result
               finish_reason:x:@http.post/*/content/*/choices/0/*/finish_reason

   /*
    * Applying some HTTP caching to avoid invoking OpenAI again with
    * the same question before some minimum amount of time has passed.
    */
   response.headers.set
      Cache-Control:max-age=30

   // Returning results returned from invocation above to caller.
   unwrap:x:+/*
   return
      result:x:@.result
