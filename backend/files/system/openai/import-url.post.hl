
/*
 * Imports the specified URL as training data by scraping the webpage
 * and generate training data from its content.
 */
.arguments
   url:string
   type:string

// Ensures user is authorized to access endpoint.
auth.ticket.verify:root

// Sanity checking invocation.
validators.mandatory:x:@.arguments/*/url
validators.url:x:@.arguments/*/url
validators.mandatory:x:@.arguments/*/type

// Retrieving URL's content
http.get:x:@.arguments/*/url

// Sanity checking above invocation
if
   not
      and
         mte:x:@http.get
            .:int:200
         lt:x:@http.get
            .:int:300
   .lambda

      // Oops, error - Logging error and returning status 500 to caller.
      lambda2hyper:x:@http.get
      log.error:Something went wrong while trying to import URL
         error:x:@lambda2hyper
      response.status.set:500
      return
         message:Something went wrong while trying to import URL

// Making sure URL returned HTML.
if
   not
      strings.starts-with:x:@http.get/*/headers/*/Content-Type
         .:text/html
   .lambda

      // Oops, doing some basic logging before we return failure to caller.
      lambda2hyper:x:@http.get
      log.error:URL did not return HTML content
         content:x:@lambda2hyper
         url:x:@.arguments/*/url
      response.status.set:400
      return
         message:URL did not return HTML content

// Converting HTML to lambda.
html2lambda:x:@http.get/*/content

// Buffer for training snippets.
.snippets

// Temp buffer for completion
.tmp-completion:

// Looping through each HTML tag in document
for-each:x:@html2lambda/*/html/*/body/**

   // Checking if this is a tag we need to handle.
   get-name:x:@.dp/#
   switch:x:@get-name

      // Headers becomes prompts.
      case:h1
      case:h2
      case:h3
      case:h4
      case:h5
      case:h6
      
         // Creating a new prompt.
         .prompt:
         
         // Trimming and adding one SP characters between each part.
         for-each:x:@.dp/#/**/\#text
            set-value:x:@.prompt
               strings.concat
                  get-value:x:@.prompt
                  strings.trim:x:@.dp/#
                     .:"\r\n\t "
                  .:" "
         set-value:x:@.prompt
            strings.trim:x:@.prompt
               .:" "

         // Adding new prompt to [.snippets] collection.
         unwrap:x:+/*/*/*
         add:x:@.snippets
            .
               .
                  prompt:x:@.prompt

      // Paragraphs becomes completions.
      case:p

         // Making sure we've added at least one prompt.
         if
            exists:x:@.snippets/*
            .lambda

               // Creating a new completion.
               .completion:

               // Trimming and adding one SP characters between each part.
               for-each:x:@.dp/#/**/\#text
                  if
                     and
                        neq:x:@.dp/#
                           .
                        neq:x:@.dp/#
                           .:
                     .lambda
                        strings.replace:x:@.dp/#
                           .:"\r"
                           .:" "
                        strings.replace:x:@strings.replace
                           .:"\n"
                           .:" "
                        strings.replace:x:@strings.replace
                           .:"\t"
                           .:" "
                        strings.replace:x:@strings.replace
                           .:"  "
                           .:" "
                        set-value:x:@.completion
                           strings.concat
                              get-value:x:@.completion
                              strings.trim:x:@strings.replace
                                 .:"\r\n\t "
                              .:" "
               set-value:x:@.completion
                  strings.trim:x:@.completion
                     .:" "

               // Verifying that paragraph actually contained some content.
               if
                  neq:x:@.completion
                     .:
                  .lambda

                     // Checking if we need to append paragraph to existing completion or create new completion.
                     if
                        exists:x:@.snippets/0/-/*/completion
                        .lambda

                           // Appending to existing completion.
                           set-value:x:@.snippets/0/-/*/completion
                              strings.concat
                                 get-value:x:@.snippets/0/-/*/completion
                                 .:"\r\n\r\n"
                                 get-value:x:@.completion

                     else

                        // Adding new prompt to [.snippets] collection.
                        unwrap:x:+/*/*
                        add:x:@.snippets/0/-
                           .
                              completion:x:@.completion

      // Lists becomes completions.
      case:ul
      case:ol

         // Making sure we've added at least one prompt.
         if
            exists:x:@.snippets/*
            .lambda

               // Looping through each list item below list element tag.
               .completion:"\r\n"
               for-each:x:@.dp/#/*/li

                  // Buffer for list item
                  .item:

                  // Trimming and adding one SP characters between each part.
                  for-each:x:@.dp/#/**/\#text
                     if
                        and
                           neq:x:@.dp/#
                              .
                           neq:x:@.dp/#
                              .:
                        .lambda
                           strings.replace:x:@.dp/#
                              .:"\r"
                              .:" "
                           strings.replace:x:@strings.replace
                              .:"\n"
                              .:" "
                           strings.replace:x:@strings.replace
                              .:"\t"
                              .:" "
                           strings.replace:x:@strings.replace
                              .:"  "
                              .:" "
                           set-value:x:@.item
                              strings.concat
                                 get-value:x:@.item
                                 strings.trim:x:@strings.replace
                                    .:"\r\n\t "
                                 .:" "
                  set-value:x:@.completion
                     strings.concat
                        get-value:x:@.completion
                        .:"\r\n- "
                        strings.trim:x:@.item
                           .:" "

               // Verifying that list actually contained some content.
               if
                  neq:x:@.completion
                     .:"\r\n"
                  .lambda

                     // Checking if we need to append paragraph to existing completion or create new completion.
                     if
                        exists:x:@.snippets/0/-/*/completion
                        .lambda

                           // Appending to existing completion.
                           set-value:x:@.snippets/0/-/*/completion
                              strings.concat
                                 get-value:x:@.snippets/0/-/*/completion
                                 get-value:x:@.completion

                     else

                        // Adding new prompt to [.snippets] collection.
                        unwrap:x:+/*/*
                        add:x:@.snippets/0/-
                           .
                              completion:x:@.completion
                        

// Connecting to database.
.count:int:0
data.connect:[generic|magic]

   // Creating training data from all [.snippets].
   for-each:x:@.snippets/*

      if
         and
            exists:x:@.dp/#/*/prompt
            exists:x:@.dp/#/*/completion
            neq:x:@.dp/#/*/prompt
               .:
            neq:x:@.dp/#/*/completion
               .:
         .lambda
         
            // Inserting prompt and completion into database.
            data.create
               table:ml_training_snippets
               values
                  prompt:x:@.dp/#/*/prompt
                  completion:x:@.dp/#/*/completion
                  type:x:@.arguments/*/type
            math.increment:x:@.count

// Returning success to caller.
unwrap:x:+/*
return
   result:success
   count:x:@.count
