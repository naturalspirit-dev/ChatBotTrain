
/*
 * Sets up authentication of system according to the arguments provided.
 */
.arguments
   databaseType:string
   password:string
   settings:string
.description:"Sets up authentication and other parts of the system according to the arguments provided."


/*
 * Ensures user is authorized to access endpoint.
 */
auth.ticket.verify:root


/*
 * Checking if JWT secret has been changed, and
 * if is has, we throw an exception to prevent the
 * system from being setup again, overriding the default
 * setup configuration.
 */
config.get:"magic:auth:secret"
if
   not
      eq
         get-value:x:@config.get
         .:THIS-IS-NOT-A-GOOD-SECRET-PLEASE-CHANGE-IT
   .lambda

      // Already done!
      throw:"Your system has already been setup. If you wish to set it up again, please set your 'magic:auth:secret' key to 'THIS-IS-NOT-A-GOOD-SECRET-PLEASE-CHANGE-IT' manually in your appsettings.json file."


/*
 * Saving settings to appsettings.json file.
 */
config.save:x:@.arguments/*/settings


/*
 * Retrieving all database from selected database type,
 * to see if 'magic' database has previously been created.
 *
 * If not, we create the 'magic' database using the specialised
 * schema declaration for the database type.
 */
.database-exists:bool:false
strings.concat
   .:magic.db.
   get-value:x:@.arguments/*/databaseType
   .:.databases
signal:x:-


/*
 * Checking if magic was returned from above invocation.
 */
.exists:bool:false
for-each:x:@signal/*/*
   if
      eq
         get-value:x:@.dp/#
         .:magic
      .lambda
         set-value:x:@.exists
            .:bool:true
if
   not
      get-value:x:@.exists
   .lambda


      /*
       * Database does not exist.
       *
       * Evaluating SQL script that creates our database, but first we must dynamically
       * determine which script to execute.
       */
      strings.concat
         .:/misc/
         get-value:x:@.arguments/*/databaseType
         .:/magic.sql


      /*
       * Loading create database SQL script file, and replacing execution slots according
       * to which database type we're dealing with.
       */
      io.file.load:x:@strings.concat
      switch:x:@.arguments/*/databaseType

         /*
          * MySQL data adapter.
          */
         case:mysql
            set-value:x:@io.file.load
               strings.concat
                  .:"create database `magic`;use `magic`;"
                  get-value:x:@io.file.load

         /*
          * Microsoft SQL Server data adapter.
          */
         case:mssql
            set-value:x:@io.file.load
               strings.concat
                  .:@"use master;
create database [magic];
GO
use [magic];
"
                  get-value:x:@io.file.load


      /*
       * Notice, for MS SQL we need to explicitly invoke [mssql.execute-batch] to
       * accommodate for "GO" statements and such.
       */
      .slot
      if
         eq
            get-value:x:@.arguments/*/databaseType
            .:mssql
         .lambda


            /*
             * MS SQL "batch" execute slot needed.
             */
            set-value:x:@.slot
               .:mssql.execute-batch


      else


         /*
          * Any other type of database.
          */
         set-value:x:@.slot
            strings.concat
               get-value:x:@.arguments/*/databaseType
               .:.execute


      /*
       * Changing names of slots now according to which slot we should
       * use to connect to database, and which slot we should use to 
       * execute SQL schema script.
       */
      set-name:x:../**/xxx.connect
         strings.concat
            get-value:x:@.arguments/*/databaseType
            .:.connect
      set-name:x:../**/xxx.execute
         get-value:x:@.slot


      /*
       * Executing create database SQL script.
       *
       * Notice, we do not connect to a specific database schema,
       * since we rely upon the default connection string, hooking us up to whatever
       * is the default, for whatever type of database we're currently connecting to.
       */
      xxx.connect
         xxx.execute:x:@io.file.load


else


   /*
    * Database already exists.
    */
   set-value:x:@.database-exists
      .:bool:true


/*
 * Trying to insert our root user.
 *
 * Notice, this will throw an exception if root user already exists.
 */
.user-exists:bool:false
try


   /*
    * Inserting the root user according to arguments given.
    *
    * Notice, this will throw an exception if the user has
    * been previously created, which might occur if the user
    * sets up an instance of magic pointing towards a database
    * that has been previously created.
    */
   unwrap:x:+/*
   io.file.execute:/system/auth/create-user.hl
      username:root
      password:x:@.arguments/*/password
      roles
         .:root

.catch


   /*
    * Need to store the fact that we need to
    * change user's password further down in file.
    *
    * This is done since although database has been created
    * previously, we still want to allow user to provide a
    * new password if he is allowed to setup system again
    * for some reasons.
    */
   if
      get-value:x:@.database-exists
      .lambda


         /*
          * Database already existed as we started out, implying
          * there was (probably) already a root user account in it
          * from before.
          */
         set-value:x:@.user-exists
            .:bool:true


/*
 * Notice, if user already existed as we started out,
 * we need to change the password of the root user.
 */
if
   get-value:x:@.user-exists
   .lambda


      /*
       * Changing root user's password.
       */
      unwrap:x:+/*
      signal:magic.change-password
         password:x:@.arguments/*/password


/*
 * Starting scheduler.
 */
scheduler.start


/*
 * Invoking slot responsible for applying license.
 *
 * Notice, this will only apply the license if it's not
 * the default version, which is 'TRIAL-VERSION'.
 */
license.apply


/*
 * Returning success to caller.
 */
log.info:System was successfully setup
return-nodes
   result:success
