
/*
 * Allows you to invoke an HTTP REST GET method on another server,
 * cryptographically secured, encrypting your payload, and
 * cryptographically signing it before it's beign sent.
 *
 * This slots assumes the other party will return a
 * cryptographically signed result, signed with the same key
 * you use to encrypt your payload. And that the other party
 * will encrypt the result for your server's private key.
 *
 * Notice, this slot requires that you have previously installed the
 * public key belonging to the server you want to invoke.
 *
 * Arguments.
 *
 * - [url] - The URL of your invocation.
 * - [payload] - The payload to transmit to the endpoint.
 */
slots.create:magic.crypto.http.patch

   /*
    * Sanity checking invocation.
    */
   validators.mandatory:x:@.arguments/*/payload
   validators.mandatory:x:@.arguments/*/url
   validators.url:x:@.arguments/*/url

   /*
    * Splitting URL to figure out its base domain.
    */
   .domain
   strings.split:x:@.arguments/*/url
      .:/
   set-value:x:@.domain
      get-value:x:@strings.split/1

   /*
    * Looking up public key from database.
    */
   .public-key
   mysql.connect:magic
      set-value:x:@.public-key
         mysql.scalar:select content from crypto_keys where domain = @domain
            @domain:x:@.domain

   /*
    * Loading private server key.
    */
   .private-key
   set-value:x:@.private-key
      io.file.load:/modules/system/crypto/keys/private-key.key

   /*
    * Creating a random session key, to use for AES (symmetric) encryption.
    */
   crypto.random
      min:32
      max:32
      format:raw

   /*
    * Symmetrically (AES) encrypting payload, using random session key.
    */
   crypto.aes.encrypt:x:@.arguments/*/payload
      password:x:@crypto.random

   /*
    * Encrypting AES session key using public key.
    */
   crypto.rsa.encrypt:x:@crypto.random
      public-key:x:@.public-key

   /*
    * Creating a signature for content based upon our private key.
    *
    * Notice, the signature is based upon the AES encrypted content, and
    * not the raw payload as supplied during invocation.
    */
   crypto.rsa.sign:x:@crypto.aes.encrypt
      private-key:x:@.private-key

   /*
    * Retrieving fingerprint of server's public key
    */
   .fingerprint
   io.file.load:/modules/system/crypto/keys/public-key.key
   crypto.hash:x:@io.file.load
      format:fingerprint

   /*
    * Invoking endpoint, now with symmetrically content, where the
    * symmetric key is encrypted using server's public key, and transmitted
    * as X-Crypto-Key HTTP header, and also cryptographically signing
    * content, using server's private key, and transmitting signature
    * as X-Crypto-Signature HTTP header.
    */
   http.patch:x:@.arguments/*/url
      headers
         X-Crypto-Key:x:@crypto.rsa.encrypt
         X-Crypto-Signature:x:@crypto.rsa.sign
         X-Crypto-Fingerprint:x:@crypto.hash
         Content-Type:application/hyperlambda
      payload:x:@crypto.aes.encrypt

   /*
    * Verifying that the above invocation was successful.
    */
   if
      and
         mte
            get-value:x:@http.patch
            .:int:200
         lt
            get-value:x:@http.patch
            .:int:300
      .lambda

         /*
          * Success status code returned from server.
          *
          * First verifying signature of response, and that it originated from
          * the trusted public key's private key owner.
          */
         crypto.rsa.verify:x:@http.patch/*/content
            signature:x:@http.patch/*/headers/*/X-Crypto-Signature
            public-key:x:@.public-key

         /*
          * Success status code returned from server.
          *
          * Then decrypting symmetric encryption key.
          */
         crypto.rsa.decrypt:x:@http.patch/*/headers/*/X-Crypto-Key
            private-key:x:@.private-key
            raw:true

         /*
          * Then using symmetric decryption key to decrypt content.
          */
         crypto.aes.decrypt:x:@http.patch/*/content
            password:x:@crypto.rsa.decrypt
   else

      /*
       * Not a success status code from server.
       */
      .error
      set-value:x:@.error
         strings.concat
            .:"Server indicated an error, return code was "
            get-value:x:@http.patch

      /*
       * Dynamically creating some 'intelligent' exception text.
       */
      if
         and
            not
               eq
                  get-value:x:@http.patch/*/content
                  .
            not
               eq
                  get-value:x:@http.patch/*/content
                  .:
         .lambda
            set-value:x:@.error
               strings.concat
                  get-value:x:@.error
                  .:", and content from server was '"
                  get-value:x:@http.patch/*/content
                  .:"'"

      /*
       * Throwing our exception now, with as much value as possible
       * from [http.patch] invocation.
       */
      throw:x:@.error

