
/*
 * Allows you to invoke an HTTP REST GET method on another server,
 * cryptographically secured, encrypting your payload, and
 * cryptographically signing it before it's beign sent.
 *
 * This slots assumes the other party will return a
 * cryptographically signed result, signed with the same key
 * you use to encrypt your payload. And that the other party
 * will encrypt the result for your server's private key.
 *
 * Notice, this slot requires that you have previously installed the
 * public key belonging to the server you want to invoke.
 *
 * Arguments.
 *
 * - [url] - The URL of your invocation.
 * - [.lambda] - The lambda object to transmit to the endpoint and evaluate at the other side.
 */
slots.create:magic.crypto.http.eval

   // Sanity checking invocation.
   validators.mandatory:x:@.arguments/*/.lambda
   validators.mandatory:x:@.arguments/*/url
   validators.url:x:@.arguments/*/url

   // Splitting URL to figure out its base domain.
   .domain
   strings.split:x:@.arguments/*/url
      .:/
   set-value:x:@.domain
      get-value:x:@strings.split/1

   // Looking up recipient's public key from database.
   .recipient-public-key
   mysql.connect:magic
      set-value:x:@.recipient-public-key
         mysql.scalar:select content from crypto_keys where domain = @domain
            @domain:x:@.domain

   // Making sure we have a public key for recipient.
   if
      eq
         get-value:x:@.recipient-public-key
         .
      .lambda
         strings.concat
            .:"You don't have an encryption key for the domain '"
            get-value:x:@.domain
            .:"'"
         throw:x:-

   // Loading server private and public key.
   .self-private-key
   .self-public-key
   set-value:x:@.self-private-key
      io.file.load:/modules/system/crypto/keys/private-key.key
   set-value:x:@.self-public-key
      io.file.load:/modules/system/crypto/keys/public-key.key

   // Creating fingerprint of our public key
   crypto.fingerprint:x:@.self-public-key

   // Encrypting message.
   lambda2hyper:x:@.arguments/*/.lambda/*
   crypto.encrypt:x:@lambda2hyper
      raw:true
      encryption-key:x:@.recipient-public-key
      signing-key:x:@.self-private-key
      signing-key-fingerprint:x:@crypto.fingerprint

   // Invoking HTTP REST endpoint.
   http.patch:x:@.arguments/*/url
      headers
         Content-Type:application/octet-stream
         Accept:application/octet-stream
      payload:x:@crypto.encrypt

   // Verifying invocation was successful.
   if
      and
         mte
            get-value:x:@http.patch
            .:int:200
         lt
            get-value:x:@http.patch
            .:int:300
      .lambda

         // Success, decrypting result of invocation to caller.
         crypto.decrypt:x:@http.patch/*/content
            decryption-key:x:@.self-private-key

         // Verifying signature of result.
         crypto.fingerprint:x:@.self-public-key
         crypto.rsa.verify:x:@crypto.decrypt
            public-key:x:@.recipient-public-key
            signature:x:@crypto.decrypt/*/signature
         hyper2lambda:x:@crypto.decrypt
         return-nodes:x:@hyper2lambda/*

   else

      // Failure!
      .msg
      set-value:x:@.msg
         strings.concat
            .:"Invocation failed, status code from other party was "
            get-value:x:@http.patch
      if
         and
            not
               eq
                  get-value:x:@http.patch/*/content
                  .
            not
               eq
                  get-value:x:@http.patch/*/content
                  .:
         .lambda
            set-value:@.msg
               strings.concat
                  get-value:x:@.msg
                  .:", and response was '"
                  get-value:x:@http.patch/*/content
                  .:"'"
      throw:x:@.msg
