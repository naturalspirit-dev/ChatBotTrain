
/*
 * Allows you to invoke an HTTP REST GET method on another server,
 * cryptographically signing your payload before it's sent, with your
 * server's private key.
 *
 * Arguments.
 *
 * - [url] - The URL of your invocation
 * - [.lambda] - The lambda object to evaluate at the other side
 */
slots.create:magic.crypto.http.eval


   /*
    * Sanity checking invocation.
    */
   validators.mandatory:x:@.arguments/*/.lambda
   validators.url:x:@.arguments/*/url


   /*
    * Loading server private and public key.
    *
    * Private key is used to sign the payload, and the public key's
    * fingerprint is a part of the payload, such that the other party
    * can verify the integrity and authenticity of the payload.
    */
   .private-key
   .public-key
   set-value:x:@.private-key
      io.file.load:/modules/system/crypto/keys/private-key.key
   set-value:x:@.public-key
      io.file.load:/modules/system/crypto/keys/public-key.key


   /*
    * Creating a fingerprint from our public key.
    */
   crypto.fingerprint:x:@.public-key


   /*
    * Creating Hyperlambda payload, and signing
    * the message with our private key.
    */
   lambda2hyper:x:@.arguments/*/.lambda/*
   crypto.sign:x:@lambda2hyper
      raw:true
      signing-key:x:@.private-key
      signing-key-fingerprint:x:@crypto.fingerprint


   /*
    * Invoking HTTP REST endpoint with signed payload.
    */
   http.patch:x:@.arguments/*/url
      headers
         Content-Type:application/octet-stream
      payload:x:@crypto.sign


   /*
    * Returning result to caller.
    */
   unwrap:x:./*/return
   add:x:./*/return
      get-nodes:x:@http.patch/*/headers
   add:x:./*/return
      get-nodes:x:@http.patch/*/content
   return:x:@http.patch
