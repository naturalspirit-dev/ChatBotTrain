import { Component, OnDestroy, OnInit } from '@angular/core';
import { Subscription } from 'rxjs';
import { EndpointsGeneralService } from 'src/app/_general/services/endpoints-general.service';
import { GeneralService } from 'src/app/_general/services/general.service';
import { Endpoint } from 'src/app/_protected/models/common/endpoint.model';
import { BackendService } from 'src/app/_protected/services/common/backend.service';
import { CrudifyService } from '../../../crud-generator/_services/crudify.service';
import { SqlService } from '../../database/_services/sql.service';
import { CodemirrorActionsService } from '../../hyper-ide/_services/codemirror-actions.service';

/**
 * Endpoint model class, for allowing user to select which endpoints
 * he or she wants to include in the generated frontend.
 */
 class EndpointEx extends Endpoint {

  /**
   * Whether or not endpoint has been selected.
   */
  selected: boolean;
}

@Component({
  selector: 'app-auto-generate',
  templateUrl: './auto-generate.component.html',
  styleUrls: ['./auto-generate.component.scss']
})
export class AutoGenerateComponent implements OnInit, OnDestroy {

  public frontendTypes: any = FrontendTypes;
  public frontendType: string = '';
  public frontendName: string = '';

  /**
   * Turns to false is "angular-service" is selected.
   */
  public isApp: boolean = true;

  public colorPalettes: any = [];
  public colorPalette: string = '';

  public themes: any = [];
  public theme: string = '';

  private endpointSubscription!: Subscription;

  /**
   * Endpoints as retrieved from backend.
   */
   endpoints: EndpointEx[];

   /**
   * List of modules we found in backend.
   */
  databases: string[] = [];

  public tables: any = [];

  public template: string = '';
  public copyRight: string = 'Automatically generated by Magic';
  public codemirrorOptions;

  private customValue;
  private customSelect;
  private args = [];

  constructor(
    private sqlService: SqlService,
    private crudifyService: CrudifyService,
    private generalService: GeneralService,
    private backendService: BackendService,
    private endpointsGeneralService: EndpointsGeneralService,
    private codemirrorActionsService: CodemirrorActionsService) { }

  ngOnInit(): void {
    this.frontendType = this.frontendTypes[1].value;
    this.getPalette();
    this.getEndpoints();
    this.codemirrorActionsService.getActions('html').then((res: any) => { this.codemirrorOptions = res })
  }

  private getPalette() {
    this.crudifyService.templateCustomArgs(this.frontendType).subscribe({
      next: (res: any) => {
        if (res) {
          this.colorPalettes = res?.palette || [];
          this.colorPalette = this.colorPalettes[0].value;

          this.themes = res?.theme || [];
          this.theme = this.themes[0].value;

          this.template = res?.intro;

          // old code
        //   const objSelect = {};
        // const objValue = {};
        // for (const idx in res) {
        //   if (res[idx]?.length && typeof res[idx] !== 'string') {
        //     objSelect[idx] = res[idx];
        //   } else {
        //     objValue[idx] = res[idx];
        //   }
        // }
        // this.customValue = objValue;
        // this.customSelect = objSelect;
        // for (const idx in this.customSelect) {
        //   if (Array.isArray(this.customSelect[idx])) {
        //     this.args[idx] = this.customSelect[idx][0].value;
        //   }
        // }
        // for (const idx in this.customValue) {
        //   this.args[idx] = this.customValue[idx];
        // }
        }
      },
      error: (error: any) => {
        this.generalService.showFeedback(error?.error?.message ?? error, 'errorMessage');
      }
    })
  }

  public changeFrontendType() {
    this.isApp = (this.frontendType === this.frontendTypes[1].value);

    if (!this.isApp) {
      this.theme = '';
      this.colorPalette = '';
    } else {
      this.colorPalette = this.colorPalettes[0].value;
      this.theme = this.themes[0].value;
    }
  }

  /**
   * Reading endpoints' list from the already fetched instance.
   */
   private getEndpoints() {
    this.endpointSubscription = this.endpointsGeneralService.endpoints.subscribe({
      next: (endpoints: Endpoint[]) => {
        if (endpoints) {
          this.endpoints = endpoints
            .filter((x: any) => !x.path.startsWith('magic/system/') && !x.path.startsWith('magic/modules/magic/'))
            .filter((x: any) => x.type === 'crud-count' || x.type === 'crud-delete' || x.type === 'crud-read' || x.type === 'crud-create' || x.type === 'crud-update')
            .map((x: any) => {
              return {
                path: x.path,
                verb: x.verb,
                consumes: x.consumes,
                produces: x.produces,
                input: x.input,
                output: x.output,
                array: x.array,
                auth: x.auth,
                type: x.type,
                description: x.description,
                selected: true,
              };
            });

          const modules: any = [];
          for (const idx of this.endpoints) {
            let moduleName = idx.path.substring('magic/modules/'.length);
            moduleName = moduleName.substring(0, moduleName.indexOf('/'));
            if (modules.findIndex((item: any) => item.name === moduleName) === -1) {
              modules.push({name: moduleName, selected: true});
            }
          }
          this.databases = modules;
          console.log(this.databases)
          this.getComponents();
        } else {
          this.refetchEndpointsList();
        }
      },
      error: (error: any) => this.generalService.showFeedback(error?.error?.message ?? error, 'errorMessage')
    });
  }

  /**
   * Fetching list of endpoints to be used throughout the app.
   * Only invokes if the list doesn't exist.
   */
  private refetchEndpointsList() {
    this.endpointsGeneralService.getEndpoints();
  }

  /**
   * Returns the names of all component that will be generated.
   */
  private getComponents() {
    this.tables = this.endpoints
      .filter(x => x.type === 'crud-count')
      .map(x => {
        const componentName = x.path.substring(14);
        return {
          name: componentName.substring(0, componentName.length - 6),
          selected: true
        };
      });
  }

  /**
   * Returns the number of selected endpoints.
   */
   selectedEndpoints() {
    return this.endpoints.filter(x => x.selected).length;
  }

  /**
   * Invoked when the user clicks a module.
   *
   * @param module Name of module
   */
  moduleClicked(module: string) {
    const moduleEndpoints = this.endpoints.filter(x => x.path.startsWith('magic/modules/' + module + '/'));
    if (moduleEndpoints.filter(x => x.selected).length === moduleEndpoints.length) {
      for (const idx of moduleEndpoints) {
        idx.selected = false;
      }
    } else {
      for (const idx of moduleEndpoints) {
        let toBeSelected = true;
        for (var idx2 of moduleEndpoints.filter(x => x.selected && x.verb === idx.verb)) {
          const split1 = idx2.path.split('/');
          const split2 = idx.path.split('/');
          if (split1[split1.length - 1] === split2[split2.length - 1]) {
            toBeSelected = false;
          }
        }
        idx.selected = toBeSelected;
      }
    }
  }

  /**
   * Invoked when a component is selected or de-selected for being generated.
   *
   * @param component Name of component that was clicked
   */
  componentClicked(component: string) {
    const components = this.endpoints
      .filter(x => x.path.endsWith('/' + component) || x.path.endsWith('/' + component + '-count'));
    const shouldSelect = components.filter(x => !x.selected).length > 0;
    for (const idx of components) {
      idx.selected = shouldSelect;
    }
  }

  /**
   * Invoked to check if the specified module to selected or not, as
   * in all endpoints have been selected for crudification.
   *
   * @param module What module to check for
   */
  moduleSelected(module: string) {
    const moduleEndpoints = this.endpoints.filter(x => x.path.startsWith('magic/modules/' + module + '/'));
    if (moduleEndpoints.filter(x => x.selected).length === moduleEndpoints.length) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * Returns true if component is selected.
   *
   * @param component Name of component to check for
   */
  componentSelected(component: string) {
    return this.endpoints
      .filter(x => x.selected)
      .filter(x => {
        return x.verb === 'get' && x.type === 'crud-count' && (x.path == 'magic/modules/' + component + '-count');
      }).length === 1;
  }

  /*
   * Invoked when user wants to generate a frontend of some sort.
   */
  public generate(
    deployLocally: boolean = true) {
    if (this.frontendName === '') {
      this.generalService.showFeedback('Please give your fontend a name', 'errorMessage');
      return;
    }
    let apiUrl = this.backendService.active.url;
    while (apiUrl.endsWith('/')) {
      apiUrl = apiUrl.substring(0, apiUrl.length - 1);
    }

    let args: any = {}
    if (this.isApp) {
      args = {
        intro: this.template,
        palette: this.colorPalette,
        theme: this.theme
      }
    }

    const svcModel = this.createServiceModel(this.endpoints.filter(x => x.selected));
    this.crudifyService.generate(
      this.frontendType,
      apiUrl + '/',
      this.frontendName,
      this.copyRight === '' ? 'Automatically generated by Magic' : this.copyRight,
      svcModel,
      deployLocally,
      args,
      () => {
        this.generalService.showFeedback(deployLocally ? 'Successfully generated in /frontend/' : 'Successfully generated', 'successMessage', 'Ok', 5000);
      })
  }

  /*
   * Creates the requires HTTP service model for generating frontend
   * from frontend data model.
   */
  private createServiceModel(endpoints: any) {
    const result: any[] = [];
    for (const idx of endpoints) {
      const tmp = {
        auth: idx.auth,
        description: idx.description,
        path: idx.path,
        type: idx.type,
        verb: idx.verb,
        input: [],
        output: [],
      };
      if (idx.input && idx.input.length > 0) {
        idx.input.sort((lhs, rhs) => {
          if (lhs.name.toLowerCase() === 'name' && rhs.name.toLowerCase() !== 'name') {
            return -1;
          }
          if (lhs.name.toLowerCase() !== 'name' && rhs.name.toLowerCase() === 'name') {
            return 1;
          }
          if (lhs.name.toLowerCase() === 'name' && rhs.name.toLowerCase() === 'name') {
            return 0;
          }
          if (lhs.name.toLowerCase().indexOf('name') >= 0 && lhs.name.indexOf('.') === -1 &&
            (rhs.name.toLowerCase().indexOf('name') === -1 || rhs.name.indexOf('.') >= 0)) {
            return -1;
          }
          if (rhs.name.toLowerCase().indexOf('name') >= 0 && rhs.name.indexOf('.') === -1 &&
            (lhs.name.toLowerCase().indexOf('name') === -1 || lhs.name.indexOf('.') >= 0)) {
            return 1;
          }
          if (lhs.lookup && !rhs.lookup) {
            return -1;
          }
          if (!lhs.lookup && rhs.lookup) {
            return 1;
          }
          if (lhs.lookup && rhs.lookup) {
            return 0;
          }
          if (lhs.type === 'string' && rhs.type !== 'string') {
            return -1;
          }
          if (lhs.type !== 'string' && rhs.type === 'string') {
            return 1;
          }
          if (lhs.type === 'string' && rhs.type === 'string') {
            return 0;
          }
          if (lhs.type === 'date' && rhs.type !== 'date') {
            return -1;
          }
          if (lhs.type !== 'date' && rhs.type === 'date') {
            return 1;
          }
          if (lhs.type === 'date' && rhs.type === 'date') {
            return 0;
          }
          return 0;
        });

        for (const idxInput of idx.input) {
          const cur: any = {
            name: idxInput.name,
            type: idxInput.type,
          };
          if (idxInput.lookup) {
            cur.lookup = idxInput.lookup;
            cur.lookup.table = cur.lookup.table.replace('dbo.', '');
            cur.lookup.service = idx.path.substring(14);
            cur.lookup.service = cur.lookup.service.substring(0, cur.lookup.service.indexOf('/')) + '.' + cur.lookup.table;
            while (cur.lookup.service.indexOf('-') > 0) {
              cur.lookup.service = cur.lookup.service.replace('-', '_');
            }
            while (cur.lookup.service.indexOf('.') > 0) {
              cur.lookup.service = cur.lookup.service.replace('.', '_');
            }
          }
          if (idxInput.handling) {
            cur.handling = idxInput.handling;
          }
          tmp.input.push(cur);
        }
      }
      if (idx.output && idx.output.length > 0) {
        idx.output.sort((lhs, rhs) => {
          if (lhs.name.toLowerCase() === 'name' && rhs.name.toLowerCase() !== 'name') {
            return -1;
          }
          if (lhs.name.toLowerCase() !== 'name' && rhs.name.toLowerCase() === 'name') {
            return 1;
          }
          if (lhs.name.toLowerCase() === 'name' && rhs.name.toLowerCase() === 'name') {
            return 0;
          }
          if (lhs.name.toLowerCase().indexOf('name') >= 0 && lhs.name.indexOf('.') === -1 &&
            (rhs.name.toLowerCase().indexOf('name') === -1 || rhs.name.indexOf('.') >= 0)) {
            return -1;
          }
          if (rhs.name.toLowerCase().indexOf('name') >= 0 && rhs.name.indexOf('.') === -1 &&
            (lhs.name.toLowerCase().indexOf('name') === -1 || lhs.name.indexOf('.') >= 0)) {
            return 1;
          }
          if (lhs.lookup && !rhs.lookup) {
            return -1;
          }
          if (!lhs.lookup && rhs.lookup) {
            return 1;
          }
          if (lhs.lookup && rhs.lookup) {
            return 0;
          }
          if (idx.type === 'crud-read') {
            let lhsIsLinked = false;
            if (lhs.name.indexOf('.') > 0) {
              const firstSplit = lhs.name.split('.')[0];
              const urlSplit = idx.path.split('/');
              if (firstSplit !== urlSplit[urlSplit.length]) {
                lhsIsLinked = true;
              }
            }
            let rhsIsLinked = false;
            if (rhs.name.indexOf('.') > 0) {
              const firstSplit = rhs.name.split('.')[0];
              const urlSplit = idx.path.split('/');
              if (firstSplit !== urlSplit[urlSplit.length]) {
                rhsIsLinked = true;
              }
            }
            if (lhsIsLinked && !rhsIsLinked) {
              return -1;
            }
            if (!lhsIsLinked && rhsIsLinked) {
              return 1;
            }
            if (lhsIsLinked && rhsIsLinked) {
              return 0;
            }
          }
          if (lhs.type === 'string' && rhs.type !== 'string') {
            return -1;
          }
          if (lhs.type !== 'string' && rhs.type === 'string') {
            return 1;
          }
          if (lhs.type === 'string' && rhs.type === 'string') {
            return 0;
          }
          if (lhs.type === 'date' && rhs.type !== 'date') {
            return -1;
          }
          if (lhs.type !== 'date' && rhs.type === 'date') {
            return 1;
          }
          if (lhs.type === 'date' && rhs.type === 'date') {
            return 0;
          }
          return 0;
        });
        for (const idxOutput of idx.output) {
          const cur: any = {
            name: idxOutput.name,
            type: idxOutput.type || tmp.input[idxOutput.name + '.eq'],
          };
          if (idxOutput.handling) {
            cur.handling = idxOutput.handling;
          }
          if (idxOutput.lookup) {
            cur.lookup = idxOutput.lookup;
            cur.lookup.table = cur.lookup.table.replace('dbo.', '');
            cur.lookup.service = idx.path.substring(14);
            cur.lookup.service = cur.lookup.service.substring(0, cur.lookup.service.indexOf('/')) + '.' + cur.lookup.table;
            while (cur.lookup.service.indexOf('.') > 0) {
              cur.lookup.service = cur.lookup.service.replace('.', '_');
            }
          }
          tmp.output.push(cur);
        }
      }
      result.push(tmp);
    }
    return result;
  }

  ngOnDestroy(): void {
    if (this.endpointSubscription) {
      this.endpointSubscription.unsubscribe();
    }
  }
}

const FrontendTypes: any = [
  {
    name: 'Angular service',
    value: 'angular-service'
  },
  {
    name: 'Angular application',
    value: 'angular'
  }
]
