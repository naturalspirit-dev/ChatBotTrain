
/*
 * Creates the [magic.mysql.read] slot.
 * Allows you to read items from a MySQL table dynamically.
 *
 * This slot will guard against SQL injection by parametrizing your
 * SQL command according to its given [query] argument collection.
 *
 * Arguments
 *
 * - [connection] - Which connection string to use.
 * - [table] - Which table to select items from.
 * - [query] - Collection of criteria that will be "and"'ed together.
 * - [order] - Optional column to order items by.
 *
 * Notice, [query]/[limit] and [query][offset] are respectively considered to
 * be the "limit" of records, and the "offset"of where to start selecting
 * items from within the table's records. [limit] defaults to 10, and [offset]
 * defaults to 0.
 *
 * If any of your [query] values contains a "%", the comparison used will be
 * a "like" comparison, otherwise it will be an "=" comparison in the
 * resulting SQL.
 */
slot:magic.mysql.read


   .arguments
      connection:string
      table:string
      query
         limit:int
         offset:int
         order:string
         direction:string


   .lambda


      /*
       * Provides pagination information.
       * Will be replaced by given arguments from caller, if specified.
       */
      .limit:int:10
      .offset:int:0


      /*
       * Removing [order] and [direction] out of main [query] collection to
       * simplify logic further down.
       */
      add:x:@.arguments
         get-nodes:x:@.arguments/*/query/*/order
      remove-node:x:@.arguments/*/query/*/order
      add:x:@.arguments
         get-nodes:x:@.arguments/*/query/*/direction
      remove-node:x:@.arguments/*/query/*/direction


      /*
       * Checking if the caller provided a [limit] argument.
       */
      if
         mt
            get-count:x:@.arguments/*/query/*/limit
            .:int:0

         .lambda
            set-value:x:@.limit
               get-value:x:@.arguments/*/query/*/limit
            remove-node:x:@.arguments/*/query/*/limit

            /*
             * [convert] will throw an exception if some funny SQL injection 
             * is attempted
             */
            set-value:x:@.limit
               convert:x:@.limit
                  type:int


      /*
       * Checking if the caller provided an [offset] argument.
       */
      if
         mt
            get-count:x:@.arguments/*/query/*/offset
            .:int:0

         .lambda
            set-value:x:@.offset
               get-value:x:@.arguments/*/query/*/offset
            remove-node:x:@.arguments/*/query/*/offset

            /*
             * [convert] will throw an exception if some funny SQL injection 
             * is attempted
             */
            set-value:x:@.offset
               convert:x:@.offset
                  type:int


      /*
       * Making sure we use [connection] argument.
       */
      set-value:x:./*/mysql.connect
         get-value:x:@.arguments/*/connection


      /*
       * Building our query, and storing it as we proceed in the [.query] node
       * below.
       * Notice, the SQL command will be parametrized by adding arguments to [mysql.select]
       * from children collection of [.query].
       * First we start out by setting the table for our SQL command.
       */
      .query:"select * from "
      set-value:x:@.query
         concat
            get-value:x:@.query
            .:"`"
            get-value:x:@.arguments/*/table
            .:"`"


      /*
       * Checking if caller provided any [query] arguments besides [limit]
       * and [offset].
       */
      if
         mt
            get-count:x:@.arguments/*/query/*
            .:int:0
         .lambda


            /*
             * [query] filtering arguments were provided by caller.
             * Adding a "where" clause to our SQL command text.
             */
            set-value:x:@.query
               concat
                  get-value:x:@.query
                  .query:" where":


            /* Used to keep track of the index number of parameter we
             * are currently looping through.
             * This is necessary to make sure we're able to append "and"
             * correctly to our SQL command text, and to name parameters
             * to SQL command.
             */
            .idx:int:0


            /*
             * Looping through each remaining [query] arguments besides [limit]
             * and [offset] and parametrizing our SQL command accordingly.
             */
            for-each:x:@.arguments/*/query/*


               /*
                * Checking if this is our first additional [query] argument, and
                * if not, we append "and" to the command before we append the
                * currently iterated filter criteria.
                */
               if
                  not
                     eq
                        get-value:x:@.idx
                        .:int:0
                  .lambda

                     set-value:x:@.query
                        concat
                           get-value:x:@.query
                           .:" and"


               /*
                * Adding the argument to the SQL command text, checking if we
                * should do a like comparison or an equal comparison first.
                */
               .operator:"="
               if
                  contains:x:@.dp/#
                     .:"%"
                  .lambda

                     set-value:x:@.operator
                        .:like

               set-value:x:@.query
                  concat
                     get-value:x:@.query
                     .:" `"
                     get-name:x:@.dp/#
                     .:"` "
                     get-value:x:@.operator
                     .:" @"
                     get-value:x:@.idx
               set-name:x:+/+/*/*
                  concat
                     .:"@"
                     get-value:x:@.idx
               set-value:x:+/*/*
                  get-value:x:@.dp/#
               add:x:@.query
                  .
                     foo:bar
               set-value:x:@.idx
                  +
                     get-value:x:@.idx
                     .:int:1


      /*
       * Making sure we append the [order].
       */
      if
         mt
            get-count:x:@.arguments/*/order
            :int:0
         .lambda

            set-value:x:@.query
               concat
                  get-value:x:@.query
                  .:" order by `"
                  get-value:x:@.arguments/*/order
                  .:"` "


            /*
             * Checking if we should order descendingly.
             */
            if
               eq
                  get-value:x:@.arguments/*/direction
                  .:desc
               .lambda

                  set-value:x:@.query
                     concat
                        get-value:x:@.query
                        .:" desc"


      /*
       * Making sure we append the [.limit].
       */
      set-value:x:@.query
         concat
            get-value:x:@.query
            .:" limit "
            get-value:x:@.limit



      /*
       * Making sure we append the [.offset].
       */
      set-value:x:@.query
         concat
            get-value:x:@.query
            .:" offset "
            get-value:x:@.offset


      /*
       * Connecting to specified [connection] database, and executing SQL
       * command from [.query] that is now dynamically built, according to
       * the specified arguments.
       * Then we return the results of execution back to caller as a lambda
       * collection.
       */
      mysql.connect


         /*
          * Adding parameters to SQL command.
          */
         add:x:+
            get-nodes:x:@.query/*


         /*
          * Executing SQL command with parameters.
          */
         mysql.select:x:@.query


         /*
          * Checking if caller provided a [limit] that was "1", and if so,
          * we only return a single object.
          */
         if
            eq
               .:int:1
               get-value:x:@.limit
            .lambda


               /*
                * Caller requested a single object.
                */
               return-nodes:x:@mysql.select/*/*


         /*
          * Caller did not request a single object, hence we return an array.
          */
         return-nodes:x:@mysql.select/*
