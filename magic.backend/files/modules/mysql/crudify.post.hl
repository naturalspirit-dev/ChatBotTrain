
/*
 * Generate an HTTP REST endpoint according to the given [.arguments].
 */
.arguments
   database:string
   table:string
   returnId:bool
   template:string
   verb:string
   auth:string
   log:string
   args


/*
 * Ensures user is authorized to access endpoint.
 */
auth.ticket.verify:root


/*
 * Creating our endpoint according to arguments given, by using [apply]
 * on the [template] file given.
 */
io.files.load:x:@.arguments/*/template
hyper2lambda:x:-
unwrap:x:+/*
apply:x:@hyper2lambda
   database:x:@.arguments/*/database
   table:x:@.arguments/*/table
   return-id:x:@.arguments/*/returnId
   args


/*
 * Then ensuring we create a log entry, if the caller wants us to do
 * such a thing.
 */
if
   not
      eq
         get-value:x:@.arguments/*/log
         .:
   .lambda
      unwrap:x:+/*/*/.log
      insert-after:x:@apply/*/.arguments
         .
            lambda2hyper:x:@.arguments/*
            .log:x:@.arguments/*/log
            strings.concat
               get-value:x:@.log
               .:" - Arguments: \r\n"
               get-value:x:@lambda2hyper
            log.info:x:@strings.concat


/*
 * Then ensuring we turn on authorization to our endpoints according
 * to caller's specifications, if caller supplied an [auth] value.
 */
if
   not
      eq
         get-value:x:@.arguments/*/auth
         .:
   .lambda
      unwrap:x:+/*/*
      insert-after:x:@apply/*/.arguments
         .
            auth.ticket.verify:x:@.arguments/*/auth


/*
 * Then making sure we do our specialized transformation,
 * according to verb requested by caller.
 */
switch:x:@.arguments/*/verb


   /*
    * HTTP DELETE special case
    */
   case:delete
      add:x:@apply/*/.arguments
         get-nodes:x:@.arguments/*/args/*/primary/*


   /*
    * HTTP GET special case
    */
   case:get
      add:x:@apply/*/.arguments
         get-nodes:x:@.arguments/*/args/*/columns/*

      /*
       * Checking if we have an [.arguments]/[args]/[cache] value.
       */
      if
         and
            not
               eq
                  get-value:x:@.arguments/*/args/*/cache
                  .:0
            not
               eq
                  get-value:x:@.arguments/*/args/*/cache
                  .:
            not
               eq
                  get-value:x:@.arguments/*/args/*/cache
                  .
         .lambda
            strings.concat
               .:private, max-age=
               get-value:x:@.arguments/*/args/*/cache
            unwrap:x:+/*/*/*
            insert-after:x:@apply/*/wait.slots.signal
               .
                  http.response.headers.add
                     Cache-Control:x:@strings.concat

      /*
       * Allowing for specifying operator to query.
       */
      .operators
         mt
         lt
         mteq
         lteq
         neq
         eq
      for-each:x:@.arguments/*/args/*/columns/*
         if
            eq
               get-value:x:@.dp/#
               .:string
            .lambda
               .buffer
                  .name:x:@.dp/#
               unwrap:x:@.buffer/*
               set-name:x:@.buffer/*
                  strings.concat
                     get-name:x:@.dp/#
                     .:.like
               add:x:@apply/*/.arguments
                  get-nodes:x:@.buffer/*
         for-each:x:@.operators/*
            .buffer
               .name:x:@.dp/@.dp/#
            unwrap:x:@.buffer/*
            set-name:x:@.buffer/*
               strings.concat
                  get-name:x:@.dp/@.dp/#
                  .:.
                  get-name:x:@.dp/#
            add:x:@apply/*/.arguments
               get-nodes:x:@.buffer/*


      for-each:x:@.arguments/*/args/*/*
         set-value:x:@.dp/#
      add:x:@apply/**/columns
         get-nodes:x:@.arguments/*/args/*/columns/*


   /*
    * HTTP POST special cases
    */
   case:post
      add:x:@apply/*/.arguments
         get-nodes:x:@.arguments/*/args/*/columns/*


   /*
    * HTTP PUT special cases
    */
   case:put
      add:x:@apply/*/.arguments
         get-nodes:x:@.arguments/*/args/*/primary/*
      add:x:@apply/*/.arguments
         get-nodes:x:@.arguments/*/args/*/columns/*
      for-each:x:@.arguments/*/args/*/*
         set-value:x:@.dp/#
      add:x:@apply/**/ids
         get-nodes:x:@.arguments/*/args/*/primary/*
      for-each:x:@apply/**/ids/*
         .x:@.arguments/*/
         set-value:x:@.x
            strings.concat
               get-value:x:@.x
               get-name:x:@.dp/#
         set-x:x:@.dp/#
            convert:x:@.x
               type:x


/*
 * Then creating our folder.
 */
.folder:/modules/
set-value:x:@.folder
   strings.concat
      get-value:x:@.folder
      get-value:x:@.arguments/*/database
      .:/
io.folders.create:x:@.folder


/*
 * Transforming lambda to hyper, and saving it to the correct file.
 */
lambda2hyper:x:@apply/*
unwrap:x:+
.filename:x:@.folder
set-value:x:@.filename
   strings.concat
      get-value:x:@.filename
      get-value:x:@.arguments/*/table
      .:.
      get-value:x:@.arguments/*/verb
      .:.hl


/*
 * Saving file, now applied according to template declaration.
 */
io.files.save:x:@.filename
   get-value:x:@lambda2hyper


/*
 * Returning success to caller.
 */
get-count:x:@apply/*
unwrap:x:+/*/loc
slots.return-nodes
   result:success
   loc:x:@get-count
