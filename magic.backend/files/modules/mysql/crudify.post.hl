
/*
 * Generate an HTTP REST endpoint according to the given
 * [.arguments].
 */
.arguments
   database:string
   table:string
   template:string
   verb:string
   args
   auth:string


/*
 * Ensures user is authorized to access endpoint.
 */
auth.verify-ticket:root


/*
 * Making sure we transform template arguments to something we can understand.
 */
for-each:x:@.arguments/*/args/**


   /*
    * Making sure this is a valid noe (that it has values).
    */
   if
      not
         eq
            get-value:x:@.dp/#
            .
      .lambda


         /*
          * Making sure we get rid of resolution.
          */
         regex-replace:x:@.dp/#
            what:\([0-9,]+\)
            with:
         replace:x:@regex-replace
            what:" unsigned"
            with:
         switch:x:@replace


            /*
             * Special case for timestamp.
             */
            case:timestamp


            /*
             * Everything transformed into date values.
             */
            case:date
            case:datetime
               set-value:x:@.dp/#
                  .:date


            /*
             * Everything transformed into decimal values.
             */
            case:float
            case:double
            case:double precision
            case:decimal
            case:dec
               set-value:x:@.dp/#
                  .:decimal


            /*
             * Everything transformed into integer long values.
             */
            case:bit
            case:tinyint
            case:bool
            case:boolean
            case:smallint
            case:mediumint
            case:integer
            case:bigint
            case:int
            case:int unsigned
               set-value:x:@.dp/#
                  .:long


            /*
             * Everything transformed into string values.
             */
            case:char
            case:varchar
            case:binary
            case:varbinary
            case:tinyblob
            case:tinytext
            case:text
            case:blob
            case:mediumtext
            case:mediumblob
            case:longtext
            case:longblob
            case:enum
            case:set
               set-value:x:@.dp/#
                  .:string


            /*
             * These are unsupported column types.
             */
            default
               if
                  starts-with:x:@replace
                     .:enum
                  .lambda


                     /*
                      * Enum type
                      */
                     set-value:x:@.dp/#
                        .:string


               else


                  /*
                   * Unsupported type.
                   */
                  .ex
                  set-value:x:@.ex
                     concat
                        get-value:x:@replace
                        .:" is currently not supported by the crudifier"
                  throw:x:@.ex


/*
 * Creating our endpoint according to arguments given, by using [apply-file]
 * on the [template] file given.
 */
unwrap:x:+/*
apply-file:x:@.arguments/*/template
   database:x:@.arguments/*/database
   table:x:@.arguments/*/table
   args


/*
 * Then ensuring we turn on authorization to our endpoints according
 * to caller's specifications.
 */
unwrap:x:+/*/*
insert-after:x:@apply-file/*/.arguments
   .
      auth.verify-ticket:x:@.arguments/*/auth


/*
 * Then making sure we do our specialized transformation.
 */
switch:x:@.arguments/*/verb

   case:delete
      add:x:@apply-file/*/.arguments
         get-nodes:x:@.arguments/*/args/*/primary/*

   case:get
      add:x:@apply-file/*/.arguments
         get-nodes:x:@.arguments/*/args/*/primary/*
      add:x:@apply-file/*/.arguments
         get-nodes:x:@.arguments/*/args/*/columns/*
      for-each:x:@.arguments/*/args/*/*
         set-value:x:@.dp/#
      add:x:@apply-file/**/columns
         get-nodes:x:@.arguments/*/args/*/columns/*
      add:x:@apply-file/**/columns
         get-nodes:x:@.arguments/*/args/*/primary/*

   case:post
      add:x:@apply-file/*/.arguments
         get-nodes:x:@.arguments/*/args/*/columns/*
      for-each:x:@.arguments/*/args/*/*
         set-value:x:@.dp/#
      add:x:@apply-file/**/exclude
         get-nodes:x:@.arguments/*/args/*/primary/*

   case:put
      add:x:@apply-file/*/.arguments
         get-nodes:x:@.arguments/*/args/*/primary/*
      add:x:@apply-file/*/.arguments
         get-nodes:x:@.arguments/*/args/*/columns/*
      for-each:x:@.arguments/*/args/*/*
         set-value:x:@.dp/#
      add:x:@apply-file/**/exclude
         get-nodes:x:@.arguments/*/args/*/primary/*
      add:x:@apply-file/**/ids
         get-nodes:x:@.arguments/*/args/*/primary/*
      for-each:x:@apply-file/**/ids/*
         .x:@.arguments/*/
         set-value:x:@.x
            concat
               get-value:x:@.x
               get-name:x:@.dp/#
         set-x:x:@.dp/#
            convert:x:@.x
               type:x


/*
 * Then creating our folder.
 */
.folder:/modules/
set-value:x:@.folder
   concat
      get-value:x:@.folder
      get-value:x:@.arguments/*/database
      .:/
create-folder:x:@.folder


/*
 * Transforming lambda to hyper, and saving it to the correct file.
 */
hyper:x:@apply-file/*
unwrap:x:+
.filename:x:@.folder
set-value:x:@.filename
   concat
      get-value:x:@.filename
      get-value:x:@.arguments/*/table
      .:.
      get-value:x:@.arguments/*/verb
      .:.hl
save-file:x:@.filename
   get-value:x:@hyper


/*
 * Returning success to caller.
 */
return-nodes
   result:success
