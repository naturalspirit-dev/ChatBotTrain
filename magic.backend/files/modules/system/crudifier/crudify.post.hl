
/*
 * Generate an HTTP REST endpoint according to the given [.arguments].
 */
.arguments
   databaseType:string
   moduleName:string
   database:string
   table:string
   returnId:bool
   template:string
   verb:string
   auth:string
   log:string
   args


/*
 * Ensures user is authorized to access endpoint.
 */
auth.ticket.verify:root


/*
 * Sanity checking module name, to prevent overwriting "/system/".
 */
strings.to-lower:x:@.arguments/*/moduleName
if
   eq
      get-value:x:@strings.to-lower
      .:system
   .lambda
      throw:"You can't use the name 'system' as your module's name"
if
   or
      eq
         get-value:x:@strings.to-lower
         .:
      eq
         get-value:x:@strings.to-lower
         .
   .lambda
      throw:"You can't use an empty string as your module's name. Your module must have a name."


/*
 * Making sure we create a valid filename.
 */
.filename
set-value:x:-
   strings.replace:x:@.arguments/*/table
      .:'.'
      .:/
set-value:x:@.filename
   strings.to-lower:x:@.filename


/*
 * Creating our endpoint according to arguments given, by using [apply]
 * on the [template] file given.
 */
io.files.load:x:@.arguments/*/template
hyper2lambda:x:-
unwrap:x:+/*
apply:x:@hyper2lambda
   database:x:@.arguments/*/database
   table:x:@.arguments/*/table
   return-id:x:@.arguments/*/returnId
   args


/*
 * Replacing generic slots with actual database type.
 */
for-each:x:@apply/**/=magic.db.xxx.create
   set-value:x:@.dp/#
      strings.concat
         .:magic.db.
         get-value:x:@.arguments/*/databaseType
         .:.create
for-each:x:@apply/**/=magic.db.xxx.delete
   set-value:x:@.dp/#
      strings.concat
         .:magic.db.
         get-value:x:@.arguments/*/databaseType
         .:.delete
for-each:x:@apply/**/=magic.db.xxx.read
   set-value:x:@.dp/#
      strings.concat
         .:magic.db.
         get-value:x:@.arguments/*/databaseType
         .:.read
for-each:x:@apply/**/=magic.db.xxx.update
   set-value:x:@.dp/#
      strings.concat
         .:magic.db.
         get-value:x:@.arguments/*/databaseType
         .:.update


/*
 * Then ensuring we create a log entry, if the caller wants us to do
 * such a thing.
 */
if
   not
      eq
         get-value:x:@.arguments/*/log
         .:
   .lambda
      unwrap:x:+/*/*/.log
      insert-after:x:@apply/*/.arguments
         .
            lambda2hyper:x:@.arguments/*
            .log:x:@.arguments/*/log
            strings.concat
               get-value:x:@.log
               .:" - Arguments: \r\n"
               get-value:x:@lambda2hyper
            log.info:x:@strings.concat


/*
 * Then ensuring we turn on authorization to our endpoints according
 * to caller's specifications, if caller supplied an [auth] value.
 */
if
   not
      eq
         get-value:x:@.arguments/*/auth
         .:
   .lambda
      unwrap:x:+/*/*
      insert-after:x:@apply/*/.arguments
         .
            auth.ticket.verify:x:@.arguments/*/auth


/*
 * Then making sure we do our specialized transformation,
 * according to verb requested by caller.
 */
switch:x:@.arguments/*/verb


   /*
    * HTTP DELETE special case
    */
   case:delete
      add:x:@apply/*/.arguments
         get-nodes:x:@.arguments/*/args/*/primary/*


   /*
    * HTTP GET special case
    */
   case:get

      /*
       * Checking if we have an [.arguments]/[args]/[cache] value.
       */
      if
         and
            not
               eq
                  get-value:x:@.arguments/*/args/*/cache
                  .:0
            not
               eq
                  get-value:x:@.arguments/*/args/*/cache
                  .:
            not
               eq
                  get-value:x:@.arguments/*/args/*/cache
                  .
         .lambda
            strings.concat
               .:private, max-age=
               get-value:x:@.arguments/*/args/*/cache
            unwrap:x:+/*/*/*
            insert-after:x:@apply/*/wait.slots.signal
               .
                  http.response.headers.add
                     Cache-Control:x:@strings.concat

      /*
       * Allowing for specifying operator to query.
       */
      .operators
         mt
         lt
         mteq
         lteq
         neq
         eq
      for-each:x:@.arguments/*/args/*/columns/*
         if
            eq
               get-value:x:@.dp/#
               .:string
            .lambda
               .buffer
                  .name:x:@.dp/#
               unwrap:x:@.buffer/*
               set-name:x:@.buffer/*
                  strings.concat
                     get-name:x:@.dp/#
                     .:.like
               add:x:@apply/*/.arguments
                  get-nodes:x:@.buffer/*
         for-each:x:@.operators/*
            .buffer
               .name:x:@.dp/@.dp/#
            unwrap:x:@.buffer/*
            set-name:x:@.buffer/*
               strings.concat
                  get-name:x:@.dp/@.dp/#
                  .:.
                  get-name:x:@.dp/#
            add:x:@apply/*/.arguments
               get-nodes:x:@.buffer/*


      for-each:x:@.arguments/*/args/*/*
         set-value:x:@.dp/#
      add:x:@apply/**/columns
         get-nodes:x:@.arguments/*/args/*/columns/*


   /*
    * HTTP POST special cases
    */
   case:post
      add:x:@apply/*/.arguments
         get-nodes:x:@.arguments/*/args/*/columns/*


   /*
    * HTTP PUT special cases
    */
   case:put
      add:x:@apply/*/.arguments
         get-nodes:x:@.arguments/*/args/*/primary/*
      add:x:@apply/*/.arguments
         get-nodes:x:@.arguments/*/args/*/columns/*
      for-each:x:@.arguments/*/args/*/*
         set-value:x:@.dp/#
      add:x:@apply/**/ids
         get-nodes:x:@.arguments/*/args/*/primary/*
      for-each:x:@apply/**/ids/*
         .x:@.arguments/*/
         set-value:x:@.x
            strings.concat
               get-value:x:@.x
               get-name:x:@.dp/#
         set-x:x:@.dp/#
            convert:x:@.x
               type:x


/*
 * Then creating our folder.
 */
.folder:/modules/
set-value:x:@.folder
   strings.concat
      get-value:x:@.folder
      get-value:x:@.arguments/*/moduleName
      .:/
strings.split:x:@.filename
   .:/
remove-node:x:-/0/-
set-value:x:@.folder
   strings.concat
      get-value:x:@.folder
      strings.join:x:@strings.split/*
         .:/
      .:/
io.folders.create:x:@.folder


/*
 * Transforming lambda to hyper, and saving it to the correct file.
 */
lambda2hyper:x:@apply/*
unwrap:x:+
.path:x:@.folder
strings.split:x:@.filename
   .:/
set-value:x:@.path
   strings.concat
      get-value:x:@.path
      get-value:x:@strings.split/0/-
      .:.
      get-value:x:@.arguments/*/verb
      .:.hl


/*
 * Figuring out filename for HTTP endpoint.
 */
strings.replace:x:@.path
   .:' '
   .:_


/*
 * Making sure folder does not exist from before.
 */
if
   io.files.exists:x:@strings.replace
   .lambda
      throw:"That module already exists. If you wish to re-create it, you'll first have to delete the existing folder with that name, inside of '/modules/'."


/*
 * Saving file, now applied according to template declaration,
 * and with the correct filename.
 */
io.files.save:x:@strings.replace
   get-value:x:@lambda2hyper


/*
 * Returning success to caller.
 */
get-count:x:@apply/*
unwrap:x:+/*/loc
slots.return-nodes
   result:success
   loc:x:@get-count
