
/*
 * Internal helper file that creates our components according to
 * which endpoints we have at our disposal.
 */
.components


/*
 * Iterating through each crud method given.
 */
for-each:x:@.arguments/*/.crud-methods/*


   /*
    * Verifying CRUD endpoint have a "read" (GET) method, otherwise we
    * don't create a component for it.
    */
   if
      exists:x:@.dp/#/*/verbs/*/get
      .lambda


         /*
          * Currently iterated endpoint can handle the GET verb, hence
          * at the minimum we should create a datagrid "view" component.
          *
          * First we make sure we gets its relative path correct.
          */
         for-each:x:@.arguments/*/.component-files/*


            /*
             * Replacing [[component-folder]].
             */
            strings.replace:x:@.dp/#
               .:[[component-folder]]
               get-value:x:@.lambda/@.dp/#/*/component-folder


            /*
             * Replacing [[component-filename]].
             */
            strings.replace:x:@strings.replace
               .:[[component-filename]]
               get-value:x:@.lambda/@.dp/#/*/component-filename


            /*
             * Buffer to hold component's filename.
             */
            unwrap:x:+
            .filename:x:@strings.replace


            /*
             * Replacing [[component-header]]
             */
            strings.replace:x:@.dp/#/*
               .:[[component-header]]
               get-value:x:@.lambda/@.dp/#/*/component-header


            /*
             * Figuring out roles that are allowed to create entities,
             * implying invoking the "create"/POST endpoint.
             */
            .create-roles
            for-each:x:@.lambda/@.dp/#/*/verbs/*/post/*/auth/*
               set-value:x:@.create-roles
                  strings.concat
                     get-value:x:@.create-roles
                     .:",'"
                     get-value:x:@.dp/#
                     .:"'"
            set-value:x:@.create-roles
               strings.trim:x:@.create-roles
                  .:,
            strings.replace:x:@strings.replace
               .:[[create-roles]]
               get-value:x:@.create-roles


            /*
             * Figuring out roles that are allowed to delete entities,
             * implying invoking the DELETE endpoint.
             */
            .delete-roles
            for-each:x:@.lambda/@.dp/#/*/verbs/*/delete/*/auth/*
               set-value:x:@.delete-roles
                  strings.concat
                     get-value:x:@.delete-roles
                     .:",'"
                     get-value:x:@.dp/#
                     .:"'"
            set-value:x:@.delete-roles
               strings.trim:x:@.delete-roles
                  .:,
            strings.replace:x:@strings.replace
               .:[[delete-roles]]
               get-value:x:@.delete-roles


            /*
             * Buffer to hold component's content.
             */
            unwrap:x:+
            .content:x:@strings.replace


            /*
             * Adding finished component to [.components] node, that is
             * returned to caller after file is done evaluating.
             */
            unwrap:x:+/+/*/*
            unwrap:x:+/*/*/*
            add:x:@.components
               .
                  :x:@.filename
                     :x:@.content


/*
 * Returns results to caller.
 */
slots.return-nodes:x:@.components/*
