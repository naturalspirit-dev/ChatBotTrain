
/*
 * Generates a frontend wrapping your HTTP REST endpoints
 * according to the specified [.arguments]. The file will use
 * the angular template to generate an Angular starter kit ZIP
 * file, doing replacements into your template, according to what
 * endpoints have been selected.
 *
 * The file will create one Angular component for each of your
 * "crud-read" endpoints that have been selected, creating a datagrid
 * for you, and a delete method/button, etc.
 *
 * The string replacements this file will perform inside your
 * template folder are as follows.
 *
 * - [[ng-containers]] - Replaced in each of your component files
 * - [[entity-details]] - View details for record in each component file
 * - [[colspan]] - Makes sure view details becomes as wide as the datagrid
 * - [[delete-input]] - Input arguments for your HTTP delete method
 * - [[filename]] - Name of component/SCSS/TS file generated for each table
 * - [[component-name]] - Name of component in TS file for each table
 * - [[columns-list]] - What columns to list in your datagrid
 * - [[service-get-method]] - Name of the HTTP GET method for table
 * - [[service-count-method]] - Name of the HTTP "count records" method for your table 
 * - [[service-delete-method]] - Delete method name
 * - [[form-control-declarations]] - Becomes FormControl declarations for each column in table
 * - [[form-control-value-subscriptions]] - Subscribe to changes to textbox in header for column
 * - [[apiUrl]] - The root URL of your API
 * - [[environmentDomain]] - The domain of your API, needed for oauth0
 * - [[service-endpoints]] - All service endpoint methods, appended into your HTTPO service file
 * - [[imports]] - Becomes import declaration of your components
 * - [[declarations]] - Becomes appended into the declarations parts of your app.module.ts
 * - [[routes]] - Becomes the router paths for all automatically generated components
 * - [[router-links]] - Becomes the router hyperlinks for all components
 * - [[name]] - Name of your app
 * - ++++
 *
 */
.description:"Generates frontend client side according to arguments given."
.arguments
   apiUrl:string
   name:string
   endpoints


/*
 * Ensures user is authorized to access endpoint.
 */
auth.ticket.verify:root


/*
 * Lists all files in Angular template folder recursively,
 * and adds them into [.files].
 */
.files
slots.signal:magic.io.files.list-recursively
   folder:/misc/templates/angular/
add:x:@.files
   get-nodes:x:@slots.signal/*


/*
 * Loading every file, and appending file's content
 * as a child node to actual file node in above [.files].
 */
for-each:x:@.files/*
   io.files.load:x:@.dp/#
   add:x:@.dp/#
      get-nodes:x:@io.files.load
   set-name:x:@.dp/#/0
      .:.


/*
 * Removing "root" of filenames, to create more friendly
 * filenames to zip file's content.
 */
for-each:x:@.files/*
   set-value:x:@.dp/#
      strings.replace:x:@.dp/#
         .:/misc/templates/angular/
         .:/magic-angular/


/*
 * Dynamically building up service methods according
 * to specified [.arguments]/[endpoints].
 */
.services:
for-each:x:@.arguments/*/endpoints/*


   /*
    * Figuring out method name.
    */
   .method
   strings.split:x:@.dp/#/*/path
      .:/
   set-value:x:@.method
      get-value:x:@strings.split/0/-
   .verb
   switch:x:@.dp/#/*/verb
      case:delete
         set-value:x:@.verb
            .:Delete
      case:get
         set-value:x:@.verb
            .:Get
      case:post
         set-value:x:@.verb
            .:Post
      case:put
         set-value:x:@.verb
            .:Put
      default
         throw:Unknown verb for HTTP endpoint
   set-value:x:@.method
      strings.concat
         strings.replace-not-of:x:@.method
            .:abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0987654321_
            .:_
         get-value:x:@.verb


   /*
    * Creating method body.
    */
   .query:
   .payload:
   switch:x:@.dp/#/*/verb
      case:delete
      case:get
         set-value:x:@.query
            .:" + this.getQueryArgs(args)"
      default
         set-value:x:@.payload
            .:", args"
   .body:@"
    return this.httpClient."
   set-value:x:@.body
      strings.concat
         get-value:x:@.body
         get-value:x:@.dp/#/*/verb
         .:"<any>(environment.apiUrl + '"
         get-value:x:@.dp/#/*/path
         .:"'"
         get-value:x:@.query
         get-value:x:@.payload
         .:");"


   /*
    * Appending entire method into [.services].
    */
   set-value:x:@.services
      strings.concat
         get-value:x:@.services
         .:"\r\n\r\n"
         .:"  "
         get-value:x:@.method
         .:"(args: any) {"
         get-value:x:@.body
         .:@"
  }"


/*
 * We need to keep track of each component we create, such that
 * we can correctly import the components into our app.module.ts file
 * after we have created all components.
 *
 * This little node does just that.
 */
.components
.modal-components


/*
 * Creating one component for each "crud-read" endpoint.
 *
 * Notice, without a "crud-read", there is no reasons to create a grid component.
 */
for-each:x:@.arguments/*/endpoints/*/*/type/=crud-read/.


   /*
    * Figuring out component filename(s).
    */
   .filename
   strings.split:x:@.dp/#/*/path
      .:/
   set-value:x:@.filename
      get-value:x:@strings.split/0/-


   /*
    * Figuring out what columns the crud-read operation returns.
    */
   .columns
   for-each:x:@.dp/#/*/returns/*
      set-value:x:+/*/*
         get-name:x:@.dp/#
      add:x:@.columns
         .
            :x:@.dp/#


   /*
    * Figuring out what columns we should show by default.
    *
    * The TS file for the component contains a list of each column
    * that should be visible in the mat-table. This is contained in
    * the "displayedColumns" field. This logic makes sure that value
    * is possible to dynamically change, such that by default, all
    * columns are shown, except primary key columns, which we by
    * default don't allow the user to change.
    */
   .columns-list:
   .columns-names
   for-each:x:@.columns/*


      /*
       * Verifying currently iterated column is in "crud-create" endpoint,
       * since if it's not, the column is an "automatic" or primary key, and we don't
       * want to display it in the grid (by default).
       */
      .display:bool:true
      for-each:x:@.arguments/*/endpoints/*
         if
            and
               eq
                  get-value:x:@.dp/#/*/path
                  get-value:x:@for-each/@for-each/@.dp/#/*/path
               eq
                  get-value:x:@.dp/#/*/type
                  .:crud-create
            .lambda
               .exists:bool:false
               for-each:x:@.dp/#/*/input/*
                  if
                     eq
                        get-name:x:@.dp/#
                        get-value:x:@.lambda/@for-each/@.dp/#
                     .lambda
                        set-value:x:@.exists
                           .:bool:true
               set-value:x:@.display
                  get-value:x:@.exists
      if
         get-value:x:@.display
         .lambda
            set-value:x:@.columns-list
               strings.concat
                  get-value:x:@.columns-list
                  .:"'"
                  get-value:x:@.dp/#
                  .:"', "
            set-name:x:+/*/*
               get-value:x:@.dp/#
            add:x:@.columns-names
               .
                  .


   /*
    * First we do replacements in our component's HTML file.
    *
    * Loading template component HTML file.
    */
   io.files.load:/misc/templates/angular-component/component.html


   /*
    * Creating one ng-container HTML snippet in HTML file for each
    * column returned from CRUD read.
    *
    * In addition, we create one "edit column value textbox" for each
    * of the column returned from the CRUD read invocation.
    */
   .container-count:int:1
   .ng-containers:
   .entity-details:
   .form-fields:
   for-each:x:@.columns/*


      /*
       * Incrementing column count, such that we can figure out "colspan"
       * to use for "details" ng-container.
       */
      set-value:x:@.container-count
         math.increment:x:@.container-count


      /*
       * Appending currently iterated column to [.ng-containers].
       */
      set-value:x:@.ng-containers
         strings.concat
            get-value:x:@.ng-containers
            .:"\r\n      <ng-container matColumnDef=\""
            get-value:x:@.dp/#
            .:@""">
        <th mat-header-cell *matHeaderCellDef>
          <mat-form-field appearance=""outline"" class=""fill-width filter-textbox"">
            <mat-label>"
            get-value:x:@.dp/#
            .:@"</mat-label>
            <input
              matInput
              placeholder=""Filter ...""
              type=""text""
              autocomplete=""off""
              [formControl]="""
            get-value:x:@.dp/#
            .:@""">
            <mat-icon matSuffix>search</mat-icon>
          </mat-form-field>
          <button
            class=""sort-button""
            (click)=""sort('"
            get-value:x:@.dp/#
            .:@"')""
            mat-button>
            <mat-icon matSuffix>{{getSortIcon('"
            get-value:x:@.dp/#
            .:@"')}}</mat-icon>
          </button>"
            .:"\r\n        </th>\r\n"
            .:@"        <td mat-cell (click)=""toggleDetails(el)"" *matCellDef=""let el"">{{el."
            get-value:x:@.dp/#
            .:"}}</td>\r\n"
            .:"      </ng-container>\r\n"


      /*
       * Appending currently iterated column to [.entity-details].
       */
      set-value:x:@.entity-details
         strings.concat
            get-value:x:@.entity-details
            .:@"            <p class=""details"">"
            .:<label>
            get-value:x:@.dp/#
            .:</label>
            .:"<span>{{el."
            get-value:x:@.dp/#
            .:"}}</span></p>\r\n"


      /*
       * Appending currently iterated column to [.form-fields], but only
       * if it's a visible column in the datagrid.
       */
      .add:bool:false
      for-each:x:@.columns-names/*
         if
            eq
               get-name:x:@.dp/#
               get-value:x:@for-each/@.dp/#
            .lambda
               set-value:x:@.add
                  .:bool:true
      if
         get-value:x:@.add
         .lambda
            set-value:x:@.form-fields
               strings.concat
                  get-value:x:@.form-fields
                  .:"\r\n  <mat-form-field\r\n"
                  .:"    class=\"entity-edit-field\">\r\n"
                  .:"    <input\r\n"
                  .:"      matInput\r\n"
                  .:"      placeholder=\""
                  get-value:x:@for-each/@.dp/#
                  .:"\"\r\n"
                  .:"      [(ngModel)]=\"data.entity."
                  get-value:x:@for-each/@.dp/#
                  .:"\"\r\n"
                  .:"      autocomplete=\"off\">\r\n"
                  .:"  </mat-form-field>\r\n"


   /*
    * Doing actual substitution in HTML file.
    *
    * More specifically, we're substituting the following strings.
    *
    * - [[ng-containers]]
    * - [[entity-details]]
    * - [[colspan]]
    */
   strings.replace:x:@io.files.load
      .:[[ng-containers]]
      get-value:x:@.ng-containers
   strings.replace:x:@strings.replace
      .:[[entity-details]]
      get-value:x:@.entity-details
   strings.replace:x:@strings.replace
      .:[[colspan]]
      get-value:x:@.container-count


   /*
    * Figuring out input to "crud-delete" endpoint, and doing
    * substitution accordingly.
    */
   .delete-input:
   for-each:x:@.arguments/*/endpoints/*
      if
         and
            eq
               get-value:x:@.dp/#/*/type
               .:crud-delete
            eq
               get-value:x:@.dp/#/*/path
               get-value:x:@for-each/@.dp/#/*/path
         .lambda
            for-each:x:@.dp/#/*/input/*
               set-value:x:@.delete-input
                  strings.concat
                     get-value:x:@.delete-input
                     get-name:x:@.dp/#
                     .:":el."
                     get-name:x:@.dp/#
                     .:,
   strings.trim:x:@.delete-input
      .:,
   strings.replace:x:-/@strings.replace
      .:[[delete-input]]
      get-value:x:@strings.trim


   /*
    * Replacing any [[filename]] occurencies in HTML file.
    */
   strings.replace:x:@strings.replace
      .:[[filename]]
      get-value:x:@.filename


   /*
    * Then we're done with the component's HTML file.
    *
    * Now adding HTML file to ZIP source.
    */
   set-value:x:+/+/*/*
      strings.concat
         .:/magic-angular/src/app/components/
         get-value:x:@.filename
         .:/
         get-value:x:@.filename
         .:.component.html
   set-value:x:+/*/*/*
      get-value:x:@strings.replace
   add:x:@.files
      .
         :
            :


   /*
    * Then loading our component's template SCSS file.
    * Notice, this file doesn't really have any replacements,
    * and is just added as is, as a helper file, the final user can
    * use as he see fit to add custom classes for his component later.
    */
   io.files.load:/misc/templates/angular-component/component.scss


   /*
    * Adding SCSS file to ZIP source.
    */
   set-value:x:+/+/*/*
      strings.concat
         .:/magic-angular/src/app/components/
         get-value:x:@.filename
         .:/
         get-value:x:@.filename
         .:.component.scss
   set-value:x:+/*/*/*
      get-value:x:@io.files.load
   add:x:@.files
      .
         :
            :


   /*
    * Then we need to do replacements in our component's TS file.
    *
    * Loading template component TS (TypeScript) file.
    */
   io.files.load:/misc/templates/angular-component/component.ts


   /*
    * Replacing any [[filename]] occurencies in TS file first.
    */
   strings.replace:x:@io.files.load
      .:[[filename]]
      get-value:x:@.filename


   /*
    * Figuring out component name, and replacing [[component-name]] with
    * the actual name of the component we want to use.
    */
   .entity-name
   .component-name
   .component-edit-modal-name
   set-value:x:@.entity-name
      strings.replace-not-of:x:@.filename
         .:abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0987654321_
         .:_
   strings.capitalize:x:@.entity-name
   set-value:x:@.component-name
      strings.concat
         get-value:x:@strings.capitalize
         .:Component
   set-value:x:@.component-edit-modal-name
      strings.concat
         get-value:x:@strings.capitalize
         .:EditModalComponent
   strings.replace:x:@strings.replace
      .:[[component-name]]
      get-value:x:@.component-name
   strings.replace:x:@strings.replace
      .:[[component-edit-modal-name]]
      get-value:x:@.component-edit-modal-name


   /*
    * Adding component's name to the list outside of for-each loop,
    * such that we can now all components we've created later.
    */
   add:x:@.components
      get-nodes:x:@.component-name
   add:x:@.modal-components
      get-nodes:x:@.component-edit-modal-name


   /*
    * Figuring out component's modal import filename.
    */
   strings.concat
      get-value:x:@.filename
      .:/modals/
      get-value:x:@.filename
      .:-edit-modal
   add:x:@.modal-components/0/-
      get-nodes:x:@strings.concat


   /*
    * Figuring out component's import filename.
    */
   strings.concat
      get-value:x:@.filename
      .:/
      get-value:x:@.filename
      .:.component
   add:x:@.components/0/-
      get-nodes:x:@strings.concat


   /*
    * Figuring out component's auth settings.
    */
   .roles:
   for-each:x:@.dp/#/*/auth/*
      set-value:x:@.roles
         strings.concat
            get-value:x:@.roles
            .:"'"
            get-value:x:@.dp/#
            .:"', "
   strings.trim:x:@.roles
      .:", "
   unwrap:x:+/*/*
   add:x:@.components/0/-
      .
         roles:x:@strings.trim


   /*
    * Adding delete instance column.
    */
   set-value:x:@.columns-list
      strings.concat
         get-value:x:@.columns-list
         .:"'delete-instance'"


   /*
    * Replacing [[columns-list]] in TypeScript file with
    * list of columns to display.
    */
   strings.replace:x:@strings.replace
      .:[[columns-list]]
      get-value:x:@.columns-list


   /*
    * Replacing service read/count/delete methods.
    *
    * This is the place in the TS file that retrieves records from the
    * server, and becomes a reference to the correct method in
    * our "http-service.ts" file.
    *
    * Notice, it will also replace the "count" method, necessary to know
    * how many total records can be found in table, with the given filter.
    *
    * In addition, it will also replace the "delete" method.
    */
   strings.replace:x:@strings.replace
      .:[[service-get-method]]
      strings.concat
         get-value:x:@.entity-name
         .:Get
   strings.replace:x:@strings.replace
      .:[[service-count-method]]
      strings.concat
         get-value:x:@.entity-name
         .:_countGet
   strings.replace:x:@strings.replace
      .:[[service-delete-method]]
      strings.concat
         get-value:x:@.entity-name
         .:Delete


   /*
    * Creating a field for each FormControl we need in our form.
    */
   .form-control-declarations:
   for-each:x:@.columns/*
      set-value:x:@.form-control-declarations
         strings.concat
            get-value:x:@.form-control-declarations
            .:"  private "
            get-value:x:@.dp/#
            .:": FormControl;\r\n"
   strings.replace:x:@strings.replace
      .:[[form-control-declarations]]
      get-value:x:@.form-control-declarations


   /*
    * Making sure we subscribe to the change event for each
    * of our form controls, with a debounce time though,
    * such that we don't drown the server with filtering requests.
    */
   .form-control-value-subscriptions:
   for-each:x:@.columns/*
      set-value:x:@.form-control-value-subscriptions
         strings.concat
            get-value:x:@.form-control-value-subscriptions
            .:"    this."
            get-value:x:@.dp/#
            .:" = new FormControl('');\r\n"
            .:"    this."
            get-value:x:@.dp/#
            .:".valueChanges\r\n"
            .:@"      .pipe(debounceTime(this.debounce), distinctUntilChanged())
      .subscribe(query => {
        this.paginator.pageIndex = 0;
        this.filter.offset = 0;
        this.hasFiltered = true;
        this.filter['"
            get-value:x:@.dp/#
            .:".eq'] = this."
            get-value:x:@.dp/#
            .:".value;\r\n"
            .:@"        this.getData();
      });
"
   strings.replace:x:@strings.replace
      .:[[form-control-value-subscriptions]]
      get-value:x:@.form-control-value-subscriptions


   /*
    * Adding component's TS file to ZIP source.
    */
   set-value:x:+/+/*/*
      strings.concat
         .:/magic-angular/src/app/components/
         get-value:x:@.filename
         .:/
         get-value:x:@.filename
         .:.component.ts
   set-value:x:+/*/*/*
      get-value:x:@strings.replace
   add:x:@.files
      .
         :
            :


   /*
    * Then we need to do replacements in our component's
    * edit/create modal window's TypeScript file.
    */
   io.files.load:/misc/templates/angular-component/modals/edit-dialog.ts


   /*
    * Replacing modal dialog's template fields.
    */
   strings.replace:x:@io.files.load
      .:[[filename]]
      get-value:x:@.filename
   strings.replace:x:@io.files.load
      .:[[edit-component-name]]
      get-value:x:@.component-edit-modal-name
   strings.replace:x:@strings.replace
      .:[[filename]]
      get-value:x:@.filename
   strings.replace:x:@strings.replace
      .:[[update-columns]]
      strings.replace:x:@.columns-list
         .:", 'delete-instance'"
         .:
   strings.replace:x:@strings.replace
      .:[[update-method]]
      strings.concat
         get-value:x:@.entity-name
         .:Put
   strings.replace:x:@strings.replace
      .:[[create-method]]
      strings.concat
         get-value:x:@.entity-name
         .:Post


   /*
    * Adding component's create/edit modal TS file to ZIP source.
    */
   set-value:x:+/+/*/*
      strings.concat
         .:/magic-angular/src/app/components/
         get-value:x:@.filename
         .:/modals/
         get-value:x:@.filename
         .:-edit-modal.ts
   set-value:x:+/*/*/*
      get-value:x:@strings.replace
   add:x:@.files
      .
         :
            :


   /*
    * Making sure we include create/edit modal window's CSS file to ZIP source.
    */
   io.files.load:/misc/templates/angular-component/modals/edit-dialog.scss


   /*
    * Adding component's create/edit modal TS file to ZIP source.
    */
   set-value:x:+/+/*/*
      strings.concat
         .:/magic-angular/src/app/components/
         get-value:x:@.filename
         .:/modals/
         get-value:x:@.filename
         .:-edit-modal.scss
   set-value:x:+/*/*/*
      get-value:x:@io.files.load
   add:x:@.files
      .
         :
            :


   /*
    * Then we need to do replacements in our component's
    * edit/create modal window's HTML file.
    */
   io.files.load:/misc/templates/angular-component/modals/edit-dialog.html


   /*
    * Replacing modal dialog's template fields.
    */
   strings.replace:x:@io.files.load
      .:[[capitalized-filename]]
      strings.capitalize:x:@.filename


   /*
    * Replacing modal dialog's template fields.
    */
   strings.replace:x:@strings.replace
      .:[[form-fields]]
      get-value:x:@.form-fields


   /*
    * Adding component's create/edit modal HTML file to ZIP source.
    */
   set-value:x:+/+/*/*
      strings.concat
         .:/magic-angular/src/app/components/
         get-value:x:@.filename
         .:/modals/
         get-value:x:@.filename
         .:-edit-modal.html
   set-value:x:+/*/*/*
      get-value:x:@strings.replace
   add:x:@.files
      .
         :
            :


/*
 * Then we need to create our imports, routes, router-links, and
 * declarations strings for substituing these inside our app.module.ts,
 * app-routing.module.ts, and app.component.html files.
 */
.imports:
.declarations:
.entry-components
.routes:
.router-links:
for-each:x:@.modal-components/*


   /*
    * First appending our import declaration into [.imports].
    */
   set-value:x:@.imports
      strings.concat
         get-value:x:@.imports
         .:"import { "
         get-value:x:@.dp/#
         .:" } from './components/"
         get-value:x:@.dp/#/0
         .:"';\r\n"


   /*
    * Then appending our declaration into [.declarations].
    */
   set-value:x:@.declarations
      strings.concat
         get-value:x:@.declarations
         .:"    "
         get-value:x:@.dp/#
         .:",\r\n"


   /*
    * Then appending our declaration into [.entry-components].
    */
   set-value:x:@.entry-components
      strings.concat
         get-value:x:@.entry-components
         .:"    "
         get-value:x:@.dp/#
         .:",\r\n"


for-each:x:@.components/*


   /*
    * First appending our import declaration into [.imports].
    */
   set-value:x:@.imports
      strings.concat
         get-value:x:@.imports
         .:"import { "
         get-value:x:@.dp/#
         .:" } from './components/"
         get-value:x:@.dp/#/0
         .:"';\r\n"


   /*
    * Then appending our declaration into [.declarations].
    */
   set-value:x:@.declarations
      strings.concat
         get-value:x:@.declarations
         .:"    "
         get-value:x:@.dp/#
         .:",\r\n"


   /*
    * Then appending our routes into [.routes].
    */
   strings.replace:x:@.dp/#/0
      .:.component
      .:
   strings.split:x:@strings.replace
      .:/
   set-value:x:@.routes
      strings.concat
         get-value:x:@.routes
         .:"  { path: '"
         get-value:x:@strings.split/0
         .:"', component: "
         get-value:x:@.dp/#
         .:" },\r\n"


   /*
    * Then appending our router links into [.router-links].
    */
   set-value:x:@.router-links
      strings.concat
         get-value:x:@.router-links
         .:"    <a\r\n"
         .:"      *ngIf=\"inRole(["
         get-value:x:@.dp/#/1
         .:"])\"\r\n"
         .:"      mat-button\r\n      routerLink=\"/"
         get-value:x:@strings.split/0
         .:"\"\r\n      routerLinkActive=\"active-link\"\r\n"
         .:"      class=\"menu-item\"\r\n"
         .:"      (click)=\"closeNavigator()\"\r\n"
         .:"      [routerLinkActiveOptions]=\"{exact:true}\">\r\n"
         .:"      <mat-icon matSuffix>grade</mat-icon>\r\n"
         .:"      <span class=\"menu-item-text\">"
         get-value:x:@strings.split/0
         .:"</span>\r\n"
         .:"    </a>\r\n"


/*
 * Then we need to find our index.html file, app.module.ts file, our http-service.ts file,
 * our environment.ts file, and our app.component.html files from our list
 * of files, and do substitutions inside of these, according to which components
 * we'll need, and other settings provided as arguments.
 */
for-each:x:@.files/*


   /*
    * Checking if this is our environment.ts file.
    */
   if
      eq
         get-value:x:@.dp/#
         .:/magic-angular/src/environments/environment.ts
      .lambda


         /*
          * [[apiUrl]] replacement.
          */
         strings.replace:x:@.dp/#/*
            .:[[apiUrl]]
            strings.concat
               .:"apiUrl: '"
               get-value:x:@.arguments/*/apiUrl
               .:"',"
         set-value:x:@.dp/#/*
            get-value:x:@strings.replace


         /*
          * [[environmentDomain]] replacement.
          */
         strings.split:x:@.arguments/*/apiUrl
            .:/
         strings.replace:x:@.dp/#/*
            .:[[environmentDomain]]
            strings.concat
               .:"apiDomain: '"
               get-value:x:@strings.split/1
               .:"',"
         set-value:x:@.dp/#/*
            get-value:x:@strings.replace


   /*
    * Checking if this is our http-service.ts file.
    */
   if
      eq
         get-value:x:@.dp/#
         .:/magic-angular/src/app/services/http-service.ts
      .lambda


         /*
          * [[service-endpoints]] replacement.
          */
         strings.replace:x:@.dp/#/*
            .:[[service-endpoints]]
            get-value:x:@.services
         set-value:x:@.dp/#/*
            get-value:x:@strings.replace


   /*
    * Checking if this is our app.module.ts file, or
    * our app-routing.module.ts file.
    */
   if
      or
         eq
            get-value:x:@.dp/#
            .:/magic-angular/src/app/app.module.ts
         eq
            get-value:x:@.dp/#
            .:/magic-angular/src/app/app-routing.module.ts
      .lambda


         /*
          * Doing actual replacements.
          *
          * First [[imports]] part.
          */
         set-value:x:@.dp/#/*
            strings.replace:x:@.dp/#/*
               .:[[imports]]
               get-value:x:@.imports


         /*
          * Then our [[declarations]] part.
          */
         set-value:x:@.dp/#/*
            strings.replace:x:@.dp/#/*
               .:[[declarations]]
               get-value:x:@.declarations


         /*
          * Then our [[entry-components]] part.
          */
         set-value:x:@.dp/#/*
            strings.replace:x:@.dp/#/*
               .:[[entry-components]]
               get-value:x:@.entry-components


         /*
          * Then our [[routes]] part.
          */
         set-value:x:@.dp/#/*
            strings.replace:x:@.dp/#/*
               .:[[routes]]
               get-value:x:@.routes


   /*
    * Checking if this is our app.component.html file.
    */
   if
      eq
         get-value:x:@.dp/#
         .:/magic-angular/src/app/app.component.html
      .lambda


         /*
          * [[router-links]] replacement.
          */
         set-value:x:@.dp/#/*
            strings.replace:x:@.dp/#/*
               .:[[router-links]]
               get-value:x:@.router-links


   /*
    * Checking if this is our app.component.html file,
    * our index.html file, or our home.component.html file.
    */
   if
      or
         eq
            get-value:x:@.dp/#
            .:/magic-angular/src/app/app.component.html
         eq
            get-value:x:@.dp/#
            .:/magic-angular/src/index.html
         eq
            get-value:x:@.dp/#
            .:/magic-angular/src/app/components/home/home.component.html
      .lambda


         /*
          * [[name]] replacement.
          */
         set-value:x:@.dp/#/*
            strings.replace:x:@.dp/#/*
               .:[[name]]
               get-value:x:@.arguments/*/name


/*
 * Making sure we get the HTTP headers correctly applied.
 */
http.response.headers.add
   Content-Type:application/zip
   Content-Disposition:@"attachment; filename=""angular-magic.zip"""
   Access-Control-Expose-Headers:Content-Disposition


/*
 * Adding [.files] to [io.content.zip-stream] invocation, and
 * returning results of zipping to caller.
 */
add:x:+
   get-nodes:x:@.files/*
io.content.zip-stream
slots.return-value:x:-
