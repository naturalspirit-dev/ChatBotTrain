
/*
 * Generates a frontend for you.
 */
.description:"Generates a frontend client side according to the given arguments."
.arguments
   templateName:string
   apiUrl:string
   name:string
   endpoints


/*
 * Ensures user is authorized to access endpoint.
 */
auth.ticket.verify:root






/*
 * This parts loads up all template files, and changes the path names,
 * to make sure we have a friendly folder structure to base our downloadable
 * zip file upon.
 */


/*
 * These two nodes will contain all files from specified template folder.
 *
 * The [.main-files] will contain the main template files.
 * The [.component-files] will contain the "per component" files.
 *
 * The latter will be used as the basis for creating one component for each
 * CRUD "read" endpoint specified by caller.
 */
.main-files
.component-files


/*
 * Loads all files in "main" Angular template folder recursively.
 */
unwrap:x:+/*/*/1
add:x:@.main-files
   slots.signal:magic.io.files.load-recursively
      strings.concat
         .:/misc/templates/
         .:x:@.arguments/*/templateName
         .:/main/


/*
 * Loads all files in "component" Angular template folder recursively.
 */
unwrap:x:+/*/*/*
add:x:@.component-files
   slots.signal:magic.io.files.load-recursively
      strings.concat
         .:/misc/templates/
         .:x:@.arguments/*/templateName
         .:/component/


/*
 * Replacing component filenames such that we can keep them
 * slightly more semantically correct before starting transformation
 * process.
 */
for-each:x:@.component-files/*
   strings.replace:x:@.dp/#
      .:component.
      .:[[component-filename]].
   strings.replace:x:@strings.replace
      strings.concat
         .:/misc/templates/
         get-value:x:@.arguments/*/templateName
         .:/component/
      .:/[[component-folder]]/
   set-value:x:@.dp/#
      get-value:x:@strings.replace


/*
 * Removing "root" of folder names, to make more friendly folder structure for
 * our downloadable ZIP file.
 */
for-each:x:@.main-files/*
   strings.concat
      .:misc/templates/
      get-value:x:@.arguments/*/templateName
      .:/main
   set-value:x:@.dp/#
      strings.replace:x:@.dp/#
         get-value:x:@strings.concat
         get-value:x:@.arguments/*/name






/*
 * Creating our HTTP Client service method implementations,
 * by invoking a helper file responsible for parsing arguments,
 * and creating our TypeScript HTTP client methods accordingly.
 */
.http-service-methods
add:x:+/*
   get-nodes:x:@.arguments/*
set-value:x:@.http-service-methods
   io.files.execute:/modules/system/endpoints/internal.helpers/create-service-methods.hl






/*
 * Retrieving all CRUD endpoints passed into our [.arguments], by
 * invoking a helper file responsible for extracting that information.
 */
.crud-methods
add:x:+/*
   get-nodes:x:@.arguments/*
add:x:@.crud-methods
   io.files.execute:/modules/system/endpoints/internal.helpers/get-crud-methods.hl






/*
 * Building our components.
 */
.components
add:x:+/+/+/*
   get-nodes:x:@.component-files
add:x:+/+/*
   get-nodes:x:@.crud-methods
unwrap:x:+/*/*
add:x:@.components
   io.files.execute:/modules/system/endpoints/internal.helpers/create-components.hl
      templateName:x:@.arguments/*/templateName


/*
 * Making sure we position our components correctly inside of our zip file.
 */
for-each:x:@.components/*
   set-value:x:@.dp/#
      strings.concat
         .:/
         get-value:x:@.arguments/*/name
         .:/src/app/components/
         get-value:x:@.dp/#
log.info:x:@.crud-methods






/*
 * Iterating through each [.main-files] and doing substitutions
 * according to specifications and META data.
 *
 * Notice, this is not completely optimal approach, since according to the
 * way our template files are looking, we could further have optimised things slightly.
 * However, to accommodate for future changes, such as for instance having the
 * name of the app in *any* file we wish, we do things this way, to make sure
 * we have a substitution process, as flexible as we possibly can.
 */
for-each:x:@.main-files/*/*


   /*
    * Replacing all [[name]] occurrencies.
    */
   set-value:x:@.dp/#
      strings.replace:x:@.dp/#
         .:[[name]]
         get-value:x:@.arguments/*/name


   /*
    * Replacing all [[apiUrl]] occurrencies.
    */
   set-value:x:@.dp/#
      strings.replace:x:@.dp/#
         .:[[apiUrl]]
         get-value:x:@.arguments/*/apiUrl


   /*
    * Replacing all [[environmentDomain]] occurrencies.
    */
   strings.split:x:@.arguments/*/apiUrl
      .:"://"
   strings.split:x:-/1
      .:/
   set-value:x:@.dp/#
      strings.replace:x:@.dp/#
         .:[[environmentDomain]]
         get-value:x:@strings.split/0


   /*
    * Replacing all [[http-client-service-method-implementations]] occurrencies.
    */
   set-value:x:@.dp/#
      strings.replace:x:@.dp/#
         .:[[http-client-service-method-implementations]]
         get-value:x:@.http-service-methods






/*
 * Returning zip file to caller.
 * Making sure we get the HTTP headers correctly applied first.
 */
strings.concat
   .:"attachment; filename=\""
   get-value:x:@.arguments/*/name
   .:".zip\""
http.response.headers.add
   Content-Type:application/zip
   Content-Disposition:x:@strings.concat
   Access-Control-Expose-Headers:Content-Disposition


/*
 * Adding [.main-files] and [.components] to [io.content.zip-stream] invocation, and
 * returning results of zipping to caller.
 */
add:x:+/+
   get-nodes:x:@.components/*
add:x:+
   get-nodes:x:@.main-files/*
io.content.zip-stream
slots.return-value:x:-
