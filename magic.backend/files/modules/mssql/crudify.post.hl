
/*
 * Generate an HTTP REST endpoint according to the given [.arguments].
 */
.arguments
   database:string
   table:string
   returnId:bool
   template:string
   verb:string
   auth:string
   log:string
   args


/*
 * Ensures user is authorized to access endpoint.
 */
auth.ticket.verify:root


/*
 * Making sure we create a valid filename.
 */
.filename
set-value:x:-
   strings.replace:x:@.arguments/*/table
      .:'.'
      .:/
set-value:x:@.filename
   strings.to-lower:x:@.filename


/*
 * Creating our endpoint according to arguments given, by using [apply]
 * on the [template] file given.
 */
io.files.load:x:@.arguments/*/template
hyper2lambda:x:-
unwrap:x:+/*
apply:x:@hyper2lambda
   database:x:@.arguments/*/database
   table:x:@.arguments/*/table
   return-id:x:@.arguments/*/returnId
   args


/*
 * Then ensuring we create a log entry, if the caller wants us to do
 * such a thing.
 */
if
   not
      eq
         get-value:x:@.arguments/*/log
         .:
   .lambda
      unwrap:x:+/*/*
      insert-after:x:@apply/*/.arguments
         .
            log.info:x:@.arguments/*/log


/*
 * Then ensuring we turn on authorization to our endpoints according
 * to caller's specifications, if caller supplied an [auth] value.
 */
if
   not
      eq
         get-value:x:@.arguments/*/auth
         .:
   .lambda
      unwrap:x:+/*/*
      insert-after:x:@apply/*/.arguments
         .
            auth.ticket.verify:x:@.arguments/*/auth


/*
 * Then making sure we do our specialized transformation,
 * according to verb requested by caller.
 */
switch:x:@.arguments/*/verb


   /*
    * HTTP DELETE special case
    */
   case:delete
      add:x:@apply/*/.arguments
         get-nodes:x:@.arguments/*/args/*/primary/*


   /*
    * HTTP GET special case
    */
   case:get
      add:x:@apply/*/.arguments
         get-nodes:x:@.arguments/*/args/*/columns/*
      for-each:x:@.arguments/*/args/*/*
         set-value:x:@.dp/#
      add:x:@apply/**/columns
         get-nodes:x:@.arguments/*/args/*/columns/*


   /*
    * HTTP POST special cases
    */
   case:post
      add:x:@apply/*/.arguments
         get-nodes:x:@.arguments/*/args/*/columns/*


   /*
    * HTTP PUT special cases
    */
   case:put
      add:x:@apply/*/.arguments
         get-nodes:x:@.arguments/*/args/*/primary/*
      add:x:@apply/*/.arguments
         get-nodes:x:@.arguments/*/args/*/columns/*
      for-each:x:@.arguments/*/args/*/*
         set-value:x:@.dp/#
      add:x:@apply/**/ids
         get-nodes:x:@.arguments/*/args/*/primary/*
      for-each:x:@apply/**/ids/*
         .x:@.arguments/*/
         set-value:x:@.x
            strings.concat
               get-value:x:@.x
               get-name:x:@.dp/#
         set-x:x:@.dp/#
            convert:x:@.x
               type:x


/*
 * Then creating our folder.
 */
.folder:/modules/
set-value:x:@.folder
   strings.concat
      get-value:x:@.folder
      get-value:x:@.arguments/*/database
      .:/
strings.split:x:@.filename
   .:/
remove-node:x:-/0/-
set-value:x:@.folder
   strings.concat
      get-value:x:@.folder
      strings.join:x:@strings.split/*
         .:/
      .:/
io.folders.create:x:@.folder


/*
 * Transforming lambda to hyper, and saving it to the correct file.
 */
lambda2hyper:x:@apply/*
unwrap:x:+
.path:x:@.folder
strings.split:x:@.filename
   .:/
set-value:x:@.path
   strings.concat
      get-value:x:@.path
      get-value:x:@strings.split/0/-
      .:.
      get-value:x:@.arguments/*/verb
      .:.hl


/*
 * Saving file, now applied according to template declaration.
 */
strings.replace:x:@.path
   .:' '
   .:_
io.files.save:x:@strings.replace
   get-value:x:@lambda2hyper


/*
 * Returning success to caller.
 */
get-count:x:@apply/*
unwrap:x:+/*/loc
slots.return-nodes
   result:success
   loc:x:@get-count
